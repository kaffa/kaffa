<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Kaffa.im - software</title><link href="https://kaffa.im/" rel="alternate"></link><link href="https://kaffa.im/feeds/software.atom.xml" rel="self"></link><id>https://kaffa.im/</id><updated>2024-04-17T12:44:00+08:00</updated><entry><title>EverEdit</title><link href="https://kaffa.im/everedit.html" rel="alternate"></link><published>2024-04-17T12:44:00+08:00</published><updated>2024-04-17T12:44:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2024-04-17:/everedit.html</id><summary type="html">&lt;p class="first last"&gt;朋友让我推荐一款 Windows 上的文本编辑器，毫无疑问，我会推荐 EverEdit。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;推荐理由&lt;/h2&gt;
&lt;p&gt;EverEdit 的作者自 2008 年开始构思开发，前身叫做 MegaxEdit，其编辑器组件是完全自研的，并不是 Scintilla 之类。&lt;/p&gt;
&lt;p&gt;我使用 EverEdit 超过十年。&lt;/p&gt;
&lt;p&gt;在此之前，我一直使用一款日本的文本编辑器，且给它提过许多关键特性的需求，如超长行编辑，CSV 处理，核心改进等。但它高昂的售价（终身价 3000 元，年价 700 元）。&lt;/p&gt;
&lt;p&gt;也用过另一款欧洲的优秀编辑器，但它常常提示你购买授权，其售价为 700 元 / 3 年。&lt;/p&gt;
&lt;p&gt;这几款的特点都是可通过脚本扩展以满足各种编辑需求，但论扩展的方便程度，还属 EverEdit 最简单。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;它满足任意需求。因为它支持任意扩展，借助 Windows COM 机制，可以实现所有需求。
一旦熟悉扩展方法后，你可以在几分钟之类编写扩展并立即执行。有一种编辑器也满足这样的设计，即 Emacs，但 lisp 生态不如 js，中文世界能熟练使用 lisp 和 emacs 函数的人非常少。&lt;/li&gt;
&lt;li&gt;它支持所有支持 Windows Script Host 技术的编程语言，都可以编写扩展，包括 JScript、VBScript、Perl、Python、Ruby、Lua、Tcl、PHP、XML、Delphi 等，以及更多我没有探索过的语言。&lt;/li&gt;
&lt;li&gt;它也适合作家、写作者、所有需要文本处理的人，而不只是程序员、处理数据的人和办公室打工人。&lt;/li&gt;
&lt;li&gt;它对中文支持的非常好，且可针对中文单独设置字体。&lt;/li&gt;
&lt;li&gt;最最关键的是，它有着一个非常友好的终生授权价：158 元。在这个价格上，它提供了相同甚至更优秀的功能，你可以终生授权使用正版软件，代价只有日本那款的十八分之一。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;优惠&lt;/h2&gt;
&lt;p&gt;购买途径：通过 &lt;a class="reference external" href="https://kaffa.im/pages/contact"&gt;联系我&lt;/a&gt; 购买。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;价格1：10% 折扣价，交个朋友。&lt;/li&gt;
&lt;li&gt;价格2：购买送免费咨询。你也可以和我一样，对这种国人的基础软件研发表示支持，以原价购买。你可以添加我的QQ，我将以我的使用和编程经验向你提供该软件使用的免费咨询服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;最近的特性预告&lt;/h2&gt;
&lt;p&gt;它已支持内置 IE，能嵌入 IE Web 应用。&lt;/p&gt;
&lt;p&gt;它即将支持 Edge 的 WebView，这样很容易在其中嵌入使用现代应用，而免去上下文切换开销。&lt;/p&gt;
&lt;/div&gt;
</content><category term="software"></category><category term="EverEdit"></category></entry><entry><title>Caffeine</title><link href="https://kaffa.im/caffeine.html" rel="alternate"></link><published>2024-04-10T13:00:00+08:00</published><updated>2024-04-10T13:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2024-04-10:/caffeine.html</id><summary type="html">&lt;p class="first last"&gt;Caffeine 能帮助你更快使用 tiddlywiki 单文件保存方案。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;痛点&lt;/h2&gt;
&lt;p&gt;进入数字花园的软件选型，我选择跟随，当我面前有 tiddlywiki 资深用户 Leslie 的数字花园&lt;a class="reference external" href="https://note.justgoidea.com/"&gt;MemEx&lt;/a&gt;和仓颉哥数字花园&lt;a class="reference external" href="https://jefftay.com/"&gt;仿生猫不会梦见电子猫粮&lt;/a&gt;作为例子时，这块是作为 KN 的一个发布目标，所以需要先亲自实践。&lt;/p&gt;
&lt;p&gt;论 tiddlywiki 持久化方案，唯免费香，我选择单文件和 GitHub 托管，它的工作流是：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;打开网址 &lt;a class="reference external" href="https://coffees.app/"&gt;https://coffees.app/&lt;/a&gt; ，编写条目，完成编写条目时，点击保存，一个名为 tiddlywiki.html 的文件会被保存到当前用户的下载目录中。&lt;/li&gt;
&lt;li&gt;将 tiddlywiki.html 复制到本地 github 目录中覆盖 index.html。&lt;/li&gt;
&lt;li&gt;提交目录到 github。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此处的痛点是，每次都做类似的事挺麻烦。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="caffeine-1"&gt;
&lt;h2&gt;Caffeine&lt;/h2&gt;
&lt;p&gt;我编写了一个脚本用来处理这种无聊的操作，简化了流程。&lt;/p&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3&gt;说明&lt;/h3&gt;
&lt;p&gt;本软件适用于 Windows 下使用 TiddlyWiki Single File + Github Pages 使用。它与 aio.cmd 一起使用实现写作保存后自动推送 GitHub。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;在保存 TiddlyWiki 条目之前，先打开命令行，进入 TiddlyWiki 目录，再运行脚本 &lt;cite&gt;caffeine.py&lt;/cite&gt;。例如：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cd /d d:/your-tiddlywiki-folder/
python caffeine.py
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;默认路径&lt;/h3&gt;
&lt;p&gt;下载目录是浏览器下载目录，也可以通过命令行参数在运行时指定：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
python caffeine.py /path-to-your-downloaded-tiddlywiki.html-file
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="macos"&gt;
&lt;h3&gt;macOS&lt;/h3&gt;
&lt;p&gt;它很容易移植到 macOS 因为它使用 watchdog。&lt;/p&gt;
&lt;p&gt;其余的也不用多说了，&lt;a class="reference external" href="https://github.com/kaffa/coffees/blob/main/caffeine.py"&gt;源码&lt;/a&gt; 面前，了无秘密，我在 Windows 上编写的，但其实非常容易也移植到 macOS 使用。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="software"></category><category term="tiddlywiki"></category></entry><entry><title>FeedDemon</title><link href="https://kaffa.im/feeddemon.html" rel="alternate"></link><published>2024-02-24T14:25:00+08:00</published><updated>2024-02-24T14:25:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2024-02-24:/feeddemon.html</id><summary type="html">&lt;p class="first last"&gt;在 Feed 这件事上，抛开 FeedDemon 的乱码瑕疵不说，它依然是我最爱的 Feed 软件。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;曾在十年前，大约是 Google Reader 被死亡的那年，我挑选过 FeedDemon 的替代软件。&lt;/p&gt;
&lt;p&gt;当时我的结论是，在线使用用 Feedly，本地使用 FeedDemon 外没替代。&lt;/p&gt;
&lt;p&gt;后来出现了 irreader，一款虽存在很多硬伤但还算好用的软件，唯二的缺点是稳定性和太占资源。&lt;/p&gt;
&lt;p&gt;有一段时间，我转到了 Feedly，一直很稳定。&lt;/p&gt;
&lt;p&gt;事隔多年，大约是 2020 年，我又再去过 &lt;a class="reference external" href="https://nickbradbury.com/"&gt;Nick Bradbury&lt;/a&gt; 的博客，我很想告诉他的 &lt;a class="reference external" href="http://www.feeddemon.com/"&gt;FeedDemon&lt;/a&gt; 依然是 Windows 上最好的阅读软件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="feeddemon2"&gt;
&lt;h2&gt;FeedDemon2&lt;/h2&gt;
&lt;p&gt;RSS 或 ATOM，对于内容分发和内容消费，都不是关键，它们只是渠道的技术背景。&lt;/p&gt;
&lt;p&gt;Feed 的确是极客思维的产物，天然反商业，它们最简单直白的方式交换内容。&lt;/p&gt;
&lt;p&gt;商业不欢迎 Feed 的道理很简单，内容的创造着和消费者点对点了，没有中间商，哪里会还需要平台？&lt;/p&gt;
&lt;p&gt;Anyway，管它呢，我还是想使用 FeedDemon 来阅读我的 Feeds。&lt;/p&gt;
&lt;p&gt;Nick Bradbury 说，他使用了一些第三方组件，且升级了 Delphi 的 Unicode 支持，所以&lt;a class="reference external" href="https://nickbradbury.com/2013/03/19/my-plan-for-feeddemon/"&gt;不太容易开源&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我于是产生了一个为自己复刻 FeedDemon 的想法，先叫做 FeedDemon2 或 FeedAngel 或 FeedLemon 吧。&lt;/p&gt;
&lt;p&gt;不知我的朋友们怎么看，是否你们也需要一个完美支持 Unicode 和中文的 FeedDemon 复刻呢，也许哪天我就开始做了。&lt;/p&gt;
&lt;/div&gt;
</content><category term="software"></category><category term="feed"></category></entry><entry><title>Emacs</title><link href="https://kaffa.im/emacs.html" rel="alternate"></link><published>2023-11-02T16:25:00+08:00</published><updated>2023-11-02T16:25:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2023-11-02:/emacs.html</id><summary type="html">&lt;p class="first last"&gt;Emacs 是我最想记录的软件之一，这里是我写的 Emacs Lisp 脚本。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.gnu.org/software/emacs/"&gt;Emacs&lt;/a&gt; 是我最想记录的软件之一，我将在此记录 Emacs Lisp 脚本。&lt;/p&gt;
&lt;object data="https://kaffa.im/static/img/2023/emacs-img.svg" type="image/svg+xml"&gt;emacs-img.svg&lt;/object&gt;
&lt;div class="section" id="powered-by-emacs"&gt;
&lt;h3&gt;Powered By Emacs&lt;/h3&gt;
&lt;img alt="created0.jpg" src="https://kaffa.im/static/img/2024/powered-by-emacs/created0.jpg" /&gt;
&lt;img alt="created1.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/created1.png" /&gt;
&lt;img alt="created2.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/created2.png" /&gt;
&lt;img alt="created3.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/created3.gif" /&gt;
&lt;img alt="created4.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/created4.gif" /&gt;
&lt;img alt="created5.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/created5.gif" /&gt;
&lt;img alt="created6.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/created6.png" /&gt;
&lt;img alt="designed0.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/designed0.png" /&gt;
&lt;img alt="emacs.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/emacs.png" /&gt;
&lt;img alt="emacsemacsemacs.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/emacsemacsemacs.gif" /&gt;
&lt;img alt="made0.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made0.png" /&gt;
&lt;img alt="made1.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made1.png" /&gt;
&lt;img alt="made10.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made10.png" /&gt;
&lt;object data="https://kaffa.im/static/img/2024/powered-by-emacs/made10.svg" type="image/svg+xml"&gt;made10.svg&lt;/object&gt;
&lt;img alt="made2.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made2.png" /&gt;
&lt;img alt="made3.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made3.png" /&gt;
&lt;img alt="made4.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/made4.gif" /&gt;
&lt;img alt="made5.jpg" src="https://kaffa.im/static/img/2024/powered-by-emacs/made5.jpg" /&gt;
&lt;img alt="made6.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/made6.gif" /&gt;
&lt;img alt="made7.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made7.png" /&gt;
&lt;img alt="made8.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made8.png" /&gt;
&lt;img alt="made9.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/made9.png" /&gt;
&lt;img alt="muse.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/muse.png" /&gt;
&lt;img alt="now0.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/now0.gif" /&gt;
&lt;img alt="nxhtml.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/nxhtml.png" /&gt;
&lt;img alt="powered.jpg" src="https://kaffa.im/static/img/2024/powered-by-emacs/powered.jpg" /&gt;
&lt;img alt="powered1.jpg" src="https://kaffa.im/static/img/2024/powered-by-emacs/powered1.jpg" /&gt;
&lt;img alt="powered2.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/powered2.png" /&gt;
&lt;img alt="powered3.jpg" src="https://kaffa.im/static/img/2024/powered-by-emacs/powered3.jpg" /&gt;
&lt;img alt="powered_green.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/powered_green.png" /&gt;
&lt;img alt="powered_orange.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/powered_orange.png" /&gt;
&lt;img alt="sink_animated.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/sink_animated.gif" /&gt;
&lt;img alt="sink_gnu.gif" src="https://kaffa.im/static/img/2024/powered-by-emacs/sink_gnu.gif" /&gt;
&lt;img alt="sink_white.png" src="https://kaffa.im/static/img/2024/powered-by-emacs/sink_white.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="software"></category><category term="Emacs"></category><category term="Emacs Lisp"></category></entry><entry><title>ALaunch</title><link href="https://kaffa.im/alaunch-your-first-productivity-software.html" rel="alternate"></link><published>2022-05-04T12:00:00+08:00</published><updated>2024-03-01T00:30:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2022-05-04:/alaunch-your-first-productivity-software.html</id><summary type="html">&lt;p class="first last"&gt;作为一名软件爱好者，我对过去20年间一直使用的启动软件进行了重制，它的预览版就是 ALaunch。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;启动软件的效率&lt;/h2&gt;
&lt;p&gt;首先，回忆我们如何启动软件，以在 Windows 平台为例，过程可能是：&lt;/p&gt;
&lt;p&gt;场景一：一名普通用户，脑海产生一个念头，比如想听歌，于是开始寻找听音乐软件，可能是网易云音乐、QQMusic，Foobar2000，AIMP等，anyway，于是需要中断当前的工作心流，进入桌面或开始菜单开始寻找，经过了5至10秒，终于找到了，并双击了它打开。&lt;/p&gt;
&lt;p&gt;场景二：一名骨灰级软件爱好者，或者一名 macOS 达人，知道 Alfred，于是在 Windows 上也找到一些类似的，可高度自定义的启动软件。这类软件的特点是，有一个全局快捷键呼出，然后可输入一批分类的自定义的字符来匹配所需要的内容。&lt;/p&gt;
&lt;p&gt;第一种明显效率低下，如果每日需要启动软件 50 次，会直接浪费 200 秒以上，还不包含心流中断的时间；对我来说，第二种也不够好，因为我并不想记得 google 搜索是 g，图片搜索是 gi，或者输入 b 是百度或者 bing。&lt;/p&gt;
&lt;p&gt;启动软件要做到只是事情的开始和入口，如果在此处依靠记忆，有点舍本逐末的意思，心智成本太高，配置迁移的成本也高。&lt;/p&gt;
&lt;p&gt;于是，我想……还是按基本原理来设计，于是 ALaunch 诞生了，逻辑如下：&lt;/p&gt;
&lt;p&gt;默认情况下，Windows 中启动指定软件和文件，需要双击启动，双击的前提是能看见它，能看见它是记得它在哪，但当所需使用的软件超过150个，就不一定记得它们放在哪，而将这么多软件的快捷方式放在桌面上也并不是一个好办法。那么……能否放在一个随时可用或触手可及的地方呢？&lt;/p&gt;
&lt;p&gt;这个电脑中，给软件和文档的“应许之地”就是 ALaunch，新建启动的方式采用拖拽，来自拟物直觉没有学习成本。&lt;/p&gt;
&lt;img alt="ALaunch Snapshot" src="https://kaffa.im/static/img/2023/alaunch-demo.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;原型&lt;/h2&gt;
&lt;p&gt;作为一名资深软件爱好者，这二十年间我至少用过千种以上的软件。有些每天都用，有些每年只用几次。这些软件按使用场景不同，可分为办公室、家庭、效率、阅读、娱乐、开发、投研、安全等。而相同的部分，我意识到我需要用一个启动软件统筹管理它们。&lt;/p&gt;
&lt;p&gt;最开始我使用 Tcl/Tk 实现了一个简单的基于 Windows 注册表存储配置的启动软件原型——Launch，我使用它管理和
统计各软件的使用时间，但后来我发现 Tcl/Tk 在表达复杂数据结构时比较弱，TclLib 和 Tklib 库不够新，也缺少标准，社区算活跃，也很精英化，该有的都有，但好些解决方案存在测试不足的问题。不足以支撑后续的开发，需要我花费很多时间填坑。&lt;/p&gt;
&lt;p&gt;在 Windows 平台，现在官方正途的本是 C# 和 C++，但 C# 依赖.Net Runtime，WinUI 总感觉慢悠悠的，对不起效率工具二字。而 C++ 开发太慢成本很高，在剩下的选项中，我尝试了 Python 的 Tkinter、PyQt/PySide、wxWidget 等，发现最小打包后的尺寸也不小。Electron 也有考虑，但同样看不上，当然，我发现了 Object Pascal 的 Lazarus，经过测试后，发现启动速度和性能差不多可以接受，但其打包的尺寸也不小。最后，我发现了 Delphi Community Ed. 于是将 Lazarus 代码作了迁移。&lt;/p&gt;
&lt;p&gt;以往我的个体软件过程，Web类的效率较高，这次迁移到 Native Client，从开发软件选型到项目计划，从到用例到设计，从编码到测试，一共耗时 7 天，约 21 小时，升级了这个小软。ALaunch，一个用拖放来管理程序和文件的的启动器，希望它可以满足大部分人对于软件启动管理的预期。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://kaffa.im/static/file/alaunch-v0.8.7z"&gt;ALaunch v0.8 下载&lt;/a&gt;，任何使用反馈都是欢迎的。&lt;/p&gt;
&lt;p&gt;若您发现 ALaunch 也节省了您的时间，或者单纯想表达谢意，可以留言。&lt;/p&gt;
&lt;p&gt;当然，以下赞赏码也是可用的，这个软件 1.0 版本时会转为友情软件，与我建立友情链接的前 100 位朋友，将附送 1 枚授权码。&lt;/p&gt;
&lt;img alt="用微信扫二维码" src="https://kaffa.im/static/img/reward.png" /&gt;
&lt;img alt="用支付宝扫二维码" src="https://kaffa.im/static/img/kaffa-alipay.png" /&gt;
&lt;/div&gt;
</content><category term="software"></category><category term="ALaunch"></category><category term="Productive"></category></entry></feed>
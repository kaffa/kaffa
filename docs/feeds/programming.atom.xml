<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Kaffa.im - programming</title><link href="https://kaffa.im/" rel="alternate"></link><link href="https://kaffa.im/feeds/programming.atom.xml" rel="self"></link><id>https://kaffa.im/</id><updated>2024-04-04T01:00:00+08:00</updated><entry><title>关于工具和编程语言的思考</title><link href="https://kaffa.im/thoughts-on-tools-and-programming-languages.html" rel="alternate"></link><published>2024-04-04T01:00:00+08:00</published><updated>2024-04-04T01:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2024-04-04:/thoughts-on-tools-and-programming-languages.html</id><summary type="html">&lt;p class="first last"&gt;这篇是关于编程语言和泛化工具断舍离的思考小记&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="magicget"&gt;
&lt;h2&gt;MagicGet&lt;/h2&gt;
&lt;img alt="magicget" src="/static/img/2024/magicget.png" /&gt;
&lt;p&gt;这是一段趣味回忆。&lt;/p&gt;
&lt;p&gt;最近有人总问我会写爬虫吗？我去搜了搜 magicget，互联网依然还记得 20 年的软件。&lt;/p&gt;
&lt;p&gt;最初一版，只是为了给晋江文学的一位写手写一抓文软件。&lt;/p&gt;
&lt;p&gt;当时我刚毕业，只会 Pascal 与 C，而这两者写网络软件时有些力不从心。&lt;/p&gt;
&lt;p&gt;接下去，我在闲暇间，自学了 C#，突然发现 WinForm 其实挺好写，这也是为啥 magicget 最初几个版本只有几十K大小的原因。&lt;/p&gt;
&lt;p&gt;因为它依赖 .Net 运行时。&lt;/p&gt;
&lt;p&gt;使用 WinForm，界面方面的问题解决了，为解决网络请求时主UI冻结的问题，我还学会了多线程。&lt;/p&gt;
&lt;p&gt;但我依然只擅长写简短程序，且不知搜索开源库，以前并没有 Github，我常去 SourceForge、CodeProject 和 Google Code。&lt;/p&gt;
&lt;p&gt;但我依然还不太会写大型软件。再然后，我个人对 .Net 的性能不满意了，而安装 .Net 1.1 运行时对用户来说，也是天然的使用门槛。&lt;/p&gt;
&lt;p&gt;当时恰好出现了 Turbo Delphi 这种免费的东西，于是我想，何不我再用另外的新方法来实现呢。&lt;/p&gt;
&lt;p&gt;于是，后来的版本，我主要使用 xml 技术来解析 xhtml 网页，最终，我学会了正则表达式，于是后续版本都改为了 Delphi 原生实现。&lt;/p&gt;
&lt;p&gt;如果还有人问，我会不会写爬虫，我会把这张图发给他。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="feedtools"&gt;
&lt;h2&gt;FeedTools&lt;/h2&gt;
&lt;p&gt;然后就是 20 年后，Vivaldi 浏览器我一直在用，有一天我把某站博客 100 多 Feed 一个个加进去，发现它居然不支持分组，也不支持导出。&lt;/p&gt;
&lt;p&gt;后来我差不多花了一晚寻找这些 Feeds 到底在哪，一时心血来潮，又花了两晚，实现了一个导出 Vivaldi Feeds 的工具。&lt;/p&gt;
&lt;img alt="FeedTools" src="/static/img/2024/feedtools.png" /&gt;
&lt;p&gt;最初，我是准备使用 Lazarus，想着还可以兼容 macOS，但 Lazarus 的 json 就把我给唬住了，我很烦躁，并不想花太多时间去填坑，于是立即换上了 Delphi Community 版本来实现。&lt;/p&gt;
&lt;p&gt;如果问我为啥不选其它，因为当时我存了一点私心，准备埋入一个 token 来支持导出 opml 时的支付。&lt;/p&gt;
&lt;p&gt;后来我又改变了想法，决定还是免费提供 &lt;a class="reference external" href="https://kaffa.im/static/file/FeedTools.zip"&gt;这个程序&lt;/a&gt; ，或者在订阅中提供。&lt;/p&gt;
&lt;p&gt;在多年后，我再次使用 Delphi 的过程中，发现它的发展非常缓慢，也依然没有完全修复稳定性的问题。&lt;/p&gt;
&lt;p&gt;除了有些比如 Unicode 和跨平台数据组件的改进外，周边也都是停滞的。&lt;/p&gt;
&lt;p&gt;其它不少地方，就像刚毕业的人的设计，可谓很难用，它的老本可真是厚啊。&lt;/p&gt;
&lt;p&gt;同样类似的功能，还是 Python 好，差不多十几行就实现了一切。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;编程语言的断舍离&lt;/h2&gt;
&lt;p&gt;虽然用过许多编程语言，但在未来新增的项目上，我将主要使用 Python、JavaScript、Rust 这三种，另 PHP 用于旧项目维护，其余编程语言的有关资料和书籍，我将全部断舍离。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;工具的断舍离&lt;/h2&gt;
&lt;p&gt;如果你需要做一个工具的挑选，只能保留一种，你会怎么选：&lt;/p&gt;
&lt;p&gt;一边是一套精美有美感且耐用的手动螺丝刀，另一边是一把普通的电动螺丝刀带有一套螺丝刀头？&lt;/p&gt;
&lt;p&gt;两者间你会选什么？选易用有效率的工具，还是选有使用乐趣的工具？&lt;/p&gt;
&lt;p&gt;这个问题对于不同性格的人来说，答案可能不一样。&lt;/p&gt;
&lt;p&gt;而对于我来说，似乎就产生的选择困难症，很可能我非常难抉择，想要都保留。&lt;/p&gt;
&lt;p&gt;到此，看似此问题只有三个选择，但还有一点考虑是，为啥你需要螺丝刀？（推翻问题本身）&lt;/p&gt;
&lt;p&gt;这种思维模式我叫它 &lt;strong&gt;出家思维&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;然后，我发现其实大部分人都不需要螺丝刀，然后就会发现，选择一件让人心情愉快的工具陪在生命里，是一件很惬意的事。&lt;/p&gt;
&lt;p&gt;如为了解决效率的问题，可以花钱解决。&lt;/p&gt;
&lt;p&gt;依赖的容易固化，所以需要变革。&lt;/p&gt;
&lt;p&gt;不要让拥有的东西（知识、身份、头衔）反成了诅咒。&lt;/p&gt;
&lt;/div&gt;
</content><category term="programming"></category></entry><entry><title>HTML回忆录</title><link href="https://kaffa.im/html-memoir.html" rel="alternate"></link><published>2024-03-20T17:00:00+08:00</published><updated>2024-03-20T17:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2024-03-20:/html-memoir.html</id><summary type="html">&lt;p class="first last"&gt;毕业都爱写老人梗，Eric Meyer 也去凑热闹了。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;起因&lt;/h2&gt;
&lt;p&gt;Mozilla 工程师 David Walsh 从公司毕业，写下了 &lt;a class="reference external" href="https://davidwalsh.name/im-so-old-1"&gt;回忆贴&lt;/a&gt; ，也让我想起了很多 HTML 老人梗。多年来，我与 HTML 纠葛的脉络，列个图。&lt;/p&gt;
&lt;object class="uml" data="https://kaffa.im/static/img/html-memoir.svg" type="image/svg+xml"&gt;有关HTML的记忆&lt;/object&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;回忆&lt;/h2&gt;
&lt;p&gt;HTML/CSS 是 &lt;span class="strike"&gt;声明式&lt;/span&gt; 描述性语言，基本你需要标题就写个 h(head)，需要段落，就写个 p(paragraph)，虽然不是 &lt;span class="strike"&gt;图灵完备的&lt;/span&gt; 啥都能实现的编程语言，但复杂起来，也需要一些绞劲脑汁地小把戏。&lt;/p&gt;
&lt;p&gt;在前 jQuery 时代，为页面在各种设备上可用，兼容性问题一定杀死过每一个 Web 开发者的脑细胞，特别是当时 IE 先进的 Quirks 模式，如 html5shiv，reset，polyfill 不可少用，还好遇见了 Eric Meyer 等一些领域专家给出了一些渐进式的解决方案，现在浏览器之间的差异性才逐渐缩小了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;共鸣&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;最初，我们不知道还需要写 doctype，后来开始写时，发现我正处于一个过渡(transitional)时代。&lt;/li&gt;
&lt;li&gt;网页布局是用 &amp;lt;table&amp;gt; 完成的，为缩小间距，可能需要 1 像素的透明图片来划线。&lt;/li&gt;
&lt;li&gt;当左右都要显示内容时，可以 float right；颜色？&amp;lt;FONT COLOR=&amp;quot;FF0000&amp;quot;&amp;gt;&lt;/li&gt;
&lt;li&gt;你采用先进的 DIV + CSS 布局，要格外小心，有些浏览器不太会计算，会把右边的 DIV 挤下去，为此，我们需要，先相对定位，先飘到很远的地方，再飘回来。&lt;/li&gt;
&lt;li&gt;可能你不知道什么是 VML，它可以画一个动态的 clock。&lt;/li&gt;
&lt;li&gt;那时的动态可以更容易，你只要 marqee 就可以，不需要 setInterval。哦，还可以 BLINK 哟。&lt;/li&gt;
&lt;li&gt;哦，你需要圆角是吗？快打开 Photoshop，你会通道+动态模糊+调节层次吗？&lt;/li&gt;
&lt;li&gt;要发布网站吗？你用 CuteFTP 还是 FTPRush&lt;/li&gt;
&lt;li&gt;把他的代码从 CVS/SVN 里拉下来，什么，冲突了？&lt;/li&gt;
&lt;li&gt;你记得 Firebug 吗？&lt;/li&gt;
&lt;li&gt;&lt;cite&gt;&amp;lt;body onload=&amp;quot;alert('Hello ' + prompt('你叫什么名字?'))&amp;quot;&amp;gt;&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;播放视频，需要正确解码器，你记得 realplayer 吗？&lt;/li&gt;
&lt;li&gt;Flash 背后居然是 ActionScript，ActionScript 就差不能读本地文件了。&lt;/li&gt;
&lt;li&gt;Dreamweaver 对 asp 和 php 3 的支持也挺好的啊。&lt;/li&gt;
&lt;li&gt;Delphi 也做过 Web 呢，Web Broker，XML 是数据结构的未来&lt;/li&gt;
&lt;li&gt;你的网页上跳动的星星是用什么做的，什么 Java Applets？&lt;/li&gt;
&lt;li&gt;Adobe Air：我就要成功了。&lt;/li&gt;
&lt;li&gt;Web Voting meant refreshing web page.&lt;/li&gt;
&lt;li&gt;哪一种 modem 声音更美妙？Dual ISDN 128K purrpurrr or ISDN 56K purrrrr?&lt;/li&gt;
&lt;li&gt;什么，PNG24? BMP 也不是不可以。&lt;/li&gt;
&lt;li&gt;JavaScript vs JScript vs VBScript&lt;/li&gt;
&lt;li&gt;你用过留言簿（guestbook）吗？&lt;/li&gt;
&lt;li&gt;你记得 IE6 修复透明 PNG 的方法吗？&lt;/li&gt;
&lt;li&gt;.htc，懂？&lt;/li&gt;
&lt;li&gt;“正在建设中” / “Under construction”&lt;/li&gt;
&lt;li&gt;&amp;quot;optimized for Internet Explorer 5.5&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;cgi-bin&amp;quot;, &amp;quot;counter.pl&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;lt;HR&amp;gt;默认就具有时髦3D质感。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上述描述，你看懂了 10 个共鸣点以上，可以悄悄地留言哦。&lt;/p&gt;
&lt;p&gt;如果你有更厉害的梗，也欢迎回复~&lt;/p&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="html"></category></entry><entry><title>C</title><link href="https://kaffa.im/me-and-the-c-programming-language.html" rel="alternate"></link><published>2023-09-26T12:11:00+08:00</published><updated>2023-09-26T12:11:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2023-09-26:/me-and-the-c-programming-language.html</id><summary type="html">&lt;p&gt;任何一个 Real 的程序员都考虑或学习过 C 语言（后文简称 C）。2023年，我试图在此说明 WHAT、HOW、WHICH、WHEN C 的问题，不说明 WHY C 的问题。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;绕不开的 C&lt;/h2&gt;
&lt;p&gt;我在大学先学习的是 Pascal，然后学习谭浩强的 C，然而听课后练习 Turbo C，却并不太懂，后来通过一本 Pascal 与 C 的比较教程进行的进一步学习，然后购买了原版的 ANSI C，又阅读了 《K&amp;amp;R C 2nd》，至今有些习题依然不太会。话说，任何一个 Real 的程序员都考虑或学习过 C。2023年，我试图在此记录一点关于 C 的事。&lt;/p&gt;
&lt;h3&gt;C 在哪&lt;/h3&gt;
&lt;p&gt;C 是从 B 演化诞生的，B 是 BCPL 的简化，BCPL 来自 CPL 提议。&lt;/p&gt;
&lt;p&gt;实现 CPL 提议的，最后分为了 Lisp 和 C，两者的差异在于 C 操作数据，Lisp 不区分操作和数据更灵活。毫不夸张说，如果我们拿起放大镜进入任何一台现代计算机，我们都会发现 C 的踪迹。&lt;/p&gt;
&lt;p&gt;BCPL 只有一种数据类型——机器字（Word），而为匹配机器的发展，C 在 B 的基础上增加了一些如字符、整数、浮点数等广泛存在于现代编程语言中的数据类型，C 也从 C++ 中轻量反哺了如泛型之类的特性。&lt;/p&gt;
&lt;p&gt;在编程语言的班级中，C 虚心学习，足够谨慎，因而在最初的时间就做对了选择，所以在跨越了半个世纪后的今天，依然可以发现它的生命力，并受它的恩惠。&lt;/p&gt;
&lt;p&gt;在表达机器的逻辑时，C 是一种比 ASM 语言高级且同样能操作硬件的低层级语言，它的表达与抽象也很完备，也可以编写所有的应用级软件。&lt;/p&gt;
&lt;p&gt;而在表达人类的商业逻辑时，C 与自带“电池”（丰富的数据结构）与“充电宝”（垃圾回收机制）的其他高级语言相比，却没有太多优势。&lt;/p&gt;
&lt;p&gt;总的来说，它更适合做的是贴近硬件的软件，如操作系统、网络协议。&lt;/p&gt;
&lt;p&gt;在我大学的时代，程序员中广泛流传着一句话：所有严肃的程序员都应学习 C，聪明的程序员使用 Delphi (Object Pascal)。&lt;/p&gt;
&lt;p&gt;故 C 的位置就是编程的底座。如果用希腊字母 π 的形态来比喻，π 的脚就是 C 和 ASM，它们并为软件世界的地基，深深扎在操作系统中；π 的横线则可以是 C++、Java、Python、PHP、JavaScript、MySQL，Redis 等等其它除 ASM 语言的 any 其他的语言和软件们。&lt;/p&gt;
&lt;h3&gt;C 从哪里来&lt;/h3&gt;
&lt;p&gt;我不是个考据派，只是比普通人更着迷一点计算机编程语言的历史，这些计算机科学早期的基本事实不但时代感很强，还晕染着程序员式的幽默。&lt;/p&gt;
&lt;p&gt;编程语言的发展的传奇基本也适合这样讲述，这就是说，你可以用比较轻松的来阅读本节，而如何理解 C 的历史也并不影响你在法拉利上写代码。&lt;/p&gt;
&lt;p&gt;通用计算机编程语言发端于上世纪 50 年代和 60 年代早期，向 C 之前追溯，会发现 C 源自于 B，幽默的说，B 烤干了 BCPL（Base Combined Programming Langurage）得其精华。&lt;/p&gt;
&lt;p&gt;BCPL 源自 CPL，而 CPL 也有剑桥编程语言的意思，它最早叫做  Cambridge Programming Language (a.k.a. Cambridge Plus London)，而后改为 Combined Programming Language。&lt;/p&gt;
&lt;p&gt;C 用 10 年时间就打好了占领软件世界的基础，在诸多编程语言的竞争中胜出，在后续的 40 多年几乎都是躺赢。&lt;/p&gt;
&lt;p&gt;在计算机的世界中，很容易出现赢家通吃的现象，这与计算机的分层抽象特性有关。C 在编程语言世界所处的位置，属于一夫当关千夫莫开的那种。&lt;/p&gt;
&lt;p&gt;毫无疑问，最早在特定的硬件上都是机器码和汇编语言，然后人们开始提议实现独立于硬件的通用代数计算机语言。可能是巧合，出现好几个 A 开头的语言，如 ALGOL、Ada，但却没有 A 语言，ALGOL 理论语言阶段的最初命名是 IAL，原是数学大会上为计算机语言脱离特定硬件体系的提议和原则。&lt;/p&gt;
&lt;p&gt;计算理论基石科学家 Donald Knuth (a.k.a. 高德纳) 就在 Burroughs 205 上用汇编实现过 ALGOL 58 编译器，ALGOL 58 继而演化为 ALGOL 60，ALGOL 60 又演化为 CPL，然后的事你已经知道了。&lt;/p&gt;
&lt;p&gt;通用编程语言从 ALGOL 60 的工作中广泛受益，它几乎标志着计算机科学的诞生，而后才有了今天的软件行业和程序员职业。&lt;/p&gt;
&lt;p&gt;时间线是这样的：&lt;/p&gt;
&lt;p&gt;1967 年，&lt;strong&gt;Matin Richards&lt;/strong&gt; 在访问 MIT 时对 CPL 做了简化，推出了 BCPL 语言。&lt;/p&gt;
&lt;p&gt;1969 年，贝尔实验室的研究员 &lt;strong&gt;Kenneth Lane Thompson&lt;/strong&gt;（后文简称 Ken）设计了 B 语言。&lt;/p&gt;
&lt;p&gt;话说那时 1969 年的美国处于一个科技爆棚、社会文化割裂、价值观颠覆、青年人叛逆的时代。在那一年，人类第一次登月，太空探索是很酷的事情，计算机是那个时代很酷的东西，于是 Ken 也做了件很酷的事，它用 B 语言写出一个计算机视频游戏 Space Travel，并灌到了大型机上。但大型机甚至和一件房子那么大，运行很贵，接入很贵，所以 Space Travel 真玩起来也很贵，分时操作系统还没搞成，于是游戏程序还会阻断其它人运行的程序。于是 Ken 想问老板要一台小型机 DEC PDP-10 玩玩，老板说会不会太奢侈了就没同意，Ken 也不死心，就找了台旧的小型机 DEC PDP-7 来重新实现 Space Travel。为让 Space Travel 在旧机器上运行，Ken 花了一个月用汇编为这台机开发了一个操作系统，叫做 Unics，在开发过程中，他也逐步沉淀了一些程序，就包括进一步简化 BCPL 后的 B 语言，这个操作系统就是原始的 UNIX 内核程序、一个编译器、一个命令解析器（Shell）、及一个小的文件系统。&lt;/p&gt;
&lt;p&gt;话说 Ken 之所以做这些的原因，就是源自于他去年和同事实现 MULTICS 这个复杂系统积累的经验和郁闷，MULTICS 的目标很宏伟，希望能实现三百人同时接入大型机，同时运行上千个程序。当然，最后这大型项目如大象一般陷入了“焦油坑”，虽然做完了，但称不上成功。而在小型机上实现的 Unics 可谓对完善与复杂的反思，相比体系庞大的硬件和软件，实现更小的程序更不容易出错，而把小的功能专一的程序相互配合起来，则也可以完成宏伟的工作。&lt;/p&gt;
&lt;p&gt;1971 年之前，Ken 已经告诉了他的同事 &lt;strong&gt;Dennis MacAlistair Ritchie&lt;/strong&gt;（后文简称 dmr），他做了个游戏很酷，很想继续在新的小型机上玩，dmr 也觉得在新小型机上玩 Space Travel 会很酷，所以加入了 Ken 的操作系统的开发。后来 DEC PDP 10 机器升级到了 PDP 11，原本单一的数据类型计算机字分为了不同规格，有 占 1 字节的字符，占 2 字节的整数，及占 4 字节的浮点数。只有机器字的 B 语言显得不够用了，dmr 觉得 Space Travel 不能在新机器上运行这件事不够酷，于是看了看 BCPL 和 B 语言 的实现，盘算着将 B 适配这台新机器，于是增加了字符、整数、浮点数，改进的 B 命名为 C 语言。&lt;/p&gt;
&lt;p&gt;至此，C 语言诞生了。&lt;/p&gt;
&lt;p&gt;为了把 C 搞得更酷，Ken 和 dmr 开始用 C 重写 Unics，之后改名为 UNIX。于是，C 和 UNIX 聚齐了，硅基文明大厦的地基打好了。&lt;/p&gt;
&lt;p&gt;可能连 C 创始人都不曾预料，C 定位简洁通用，让它在后面的二十年中风靡全世界，另一个成果 UNIX 也形成了 POSIX 标准，之后编程的传奇才得以在 GNU/Linux、BSD/MacOS、WinNT 中继续续写。&lt;/p&gt;
&lt;p&gt;更细节的 C 的历史可见于欧洲的大学教授的课堂和贝尔实验室的回忆中，C 之后的版本特性，扩展和库一直在扩充，用 C 开发的软件中，有的随按规范一直在更新，有的用于教学用途，这些创造者们或已经老去或离开了这个世界，但他们传奇的人生背后的思想和作品一起留在了这个世界。&lt;/p&gt;
&lt;h3&gt;C 会去哪儿&lt;/h3&gt;
&lt;p&gt;如果你和我一样好奇过“未来学”，你会发现还没有人可以预言未来，但却有人不断预言未来。&lt;/p&gt;
&lt;p&gt;适合用 C 实现的东西已用 C 实现。目前 C 已是主流操作系统（Unix/Linux/Windows/macOS）、软件库（lib）、软件包（packages）的基石，从操作系统到编程语言，到数据库和中间件，这也意味着 C 所能构建的一切非常广泛。比如 UNIX、Linux、Git、PHP、Apache、MySQL、SQLite、Lua、Redis、Memcached 等，这些软件从底层到编程语言到中间件，对现代开发都足够自洽，现代应用级软件，都是在 C 开发的软件上开发的。&lt;/p&gt;
&lt;p&gt;不适合用 C 实现的未来也不会用 C 实现。从职业的角度上说，至少在 2023 年的当下——C 诞生 50 多年的今天，广泛的等同 C 程序员的职位一般会演化为 C++ 职位，除非业务强依赖于 C，否则不会只需要 C 程序员。这意味着，市场并没有那么多的要求纯 C 语言的程序员职位，也意味着，即使即使你非常熟悉 C，但不熟悉其他语言（即使你能很快学会其他语言），也很可能找不到 C 相关的工作。（也有例外，强如 Linus 的人除外）；另一方面，一个 C 专家肯定得是一名 Real 程序员且且英文良好，因为 C 程序员绕不开操作系统和网络的原始文档，虽然部分文档中某些重要的部分被不完整的翻译为了中文，但整体并没有实时更新的中文版本。如果公司需要 C 程序员维护现有程序，中文文档也还够，从 Unix/Linux 入手需看看 POSIX、多线程、Socket、异步编程、并发模型，性能调优，网络协议、网络安全，从 Windows 入手需懂得 Windows API 和 SDK，GUI 编程，Direct X 编程。如果公司需要创立新产品，核心部分很可能没有中文文档。&lt;/p&gt;
&lt;p&gt;值得注意的是，我关于职业个人观点也许只适用这几年，未来如果 C 程序员就业市场发生了变化，比如新的技术兴起，IoT、边缘计算、穿戴设备，旧的技术没落都有周期，自也不必惊讶。世界本就是三十年河东、三十年河西。对于 C 来说，未来职位趋势是 L 型减少的，但已经入局的人始终可以稳固掌控计算机系统层级的东西，六十年也并不久，计算机结构依然是冯·诺依曼式的，&lt;code&gt;CPU（Cache） + Memory（RAM+ROM） + Storage + IO Device&lt;/code&gt;，没有变化过。&lt;/p&gt;
&lt;p&gt;所以，假设你的工作正在使用 C，这里分两种情况：你从事的领域指定使用 C，比如芯片、实时系统、 C 嵌入式开发、游戏引擎、音频、视频算法等，你可以继续在行业潜心发展；你从事的业务你所在公司用 C 实现的，但行业内还有其他语言实现，这种情况下，不妨未雨绸缪，关注系统编程语言的发展，比如考虑学习 Rust，相比其他语言，它有着结构化的竞争优势还呈快速增长趋势，已被 Linux 和 Windows 和 Web 世界接纳的系统编程语言，比如考虑学习 Go，它的作者之一，也是 C 的作者之一。&lt;/p&gt;
&lt;h2&gt;使用 C&lt;/h2&gt;
&lt;p&gt;C 优秀，但 C 也有不少陷阱与缺陷；我在其他语言的编程习惯是，只用最通用和最简单的特性，但在 C 这里会不适用了，C 的特性是为编写操作系统极致控制机器而生，C 总会使用也应使用到。&lt;/p&gt;
&lt;h3&gt;使用前&lt;/h3&gt;
&lt;p&gt;如果有本书叫做《C 的食用指南》，那么会分为几块来讲述：首先是准备食材，其次是烹饪调味，最后即可起锅食用。&lt;/p&gt;
&lt;p&gt;准备食材。最需要了解的是 C 食谱——语法和库。遵循这些，即可编写 C 程序源代码，代码介质不重要，大脑里、写在纸上、输入在文本编辑器中——重要的是遵循语法并利用库表达程序的思想。&lt;/p&gt;
&lt;p&gt;C 语法和库是世界标准，经历了多个版本，从最初的 K&amp;amp;R C、ANSI C，到 C99，C11 等，其主要成分基本不变（计算机体系结构也没有变，只是现代计算机系统相互组合为分布式了），所以一个较懒的做法是只学习一种旧的却广泛使用的标准，就是 C99。目前来看此版本会保持向后兼容，有很多库并不追新就会停留在 C99。&lt;/p&gt;
&lt;p&gt;烹饪调味。这需要选一口好锅。即编译、调试、验证，看看程序功能是否满足预期。在进入 C 语法的讲述前，程序员们喜欢挑选一款自己喜欢的文本编辑器，这可不是一件简单的事，传说不通阵营还发生过”圣战“，可见这个过程充满仪式感，就好比哈利波特在奧利凡德商店挑选魔杖一般。如果你对此没把握或不熟悉，可以进入 C 的工具和 C 编译器中先准备准备再继续阅读。有了文本编辑器和编译器，则可以开始编译、调试、验证，一个有追求的厨师，会反复做，反复测试。&lt;/p&gt;
&lt;p&gt;起锅食用。重复烹饪调味直到程序达到了预期后，会把得到的菜端上桌子供客人食用。菜就是编译出的最终程序。客人或许不知道你是怎么做出来的，但一定能试出菜好不好吃。&lt;/p&gt;
&lt;h3&gt;hello world&lt;/h3&gt;
&lt;p&gt;语言的创造者们，总是以 hello world 程序开始讲述，K&amp;amp;R C 的 hello world 程序如下，就是我们常说的源代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello, world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上文本文件通过构建会生成可执行文件，构建又可分为编译和链接两步，满足操作系统格式的可执行文件则能在操作系统中运行了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构建（Build） = 源代码（source code）-&amp;gt;(编译 Compile)-&amp;gt;目标代码（object code）-&amp;gt;(链接 Link)-&amp;gt;可执行文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习使用 C 需要亲自进行构建实践，根据天赋的差异，每个人可能需要 Build 几百次到几万次不等，才会真正学会它。&lt;/p&gt;
&lt;p&gt;假设你在 Windows 上使用，我会推荐 EverEdit 文本编辑器，它自带 C 模式中含有 TCC 编译器，是学习 C 编程的简单起点。可以通过 TCC 菜单下的 Run，运行这段代码。TCC Run 背后省略了上述过程，直接运行了生成的可执行文件。&lt;/p&gt;
&lt;h3&gt;C 语法&lt;/h3&gt;
&lt;p&gt;系统的讲述 C 语法这件事，已有非常好的出版物和在线参考，我已经将它们放在了附录部分。&lt;/p&gt;
&lt;h3&gt;C 工具&lt;/h3&gt;
&lt;h4&gt;文本编辑器&lt;/h4&gt;
&lt;p&gt;文本编辑器，是初学 C 推荐的，IDE 是工作使用到。在不同的操作系统中，有许多花钱的和不花钱的。&lt;/p&gt;
&lt;p&gt;一般不花钱的工具都需要花时间，需要自行配置一下或几下才好用，如 Emacs、VIM、NetBeans、Eclipse、VSCode、Code::Blocks、CodeLite 这几个都是跨平台的，现在 VSCode 有一统天下之势。&lt;/p&gt;
&lt;p&gt;也有几个平台专属的好用的：Windows 上毫无疑问选 Microsoft 家的 Visual Studio Community Edition，复杂且完善，它由多个产品合并起来，其前身支持 C 的组件叫做 Visual C++ Express；被时代遗忘的源自名门 Borland Software 的被 Embarcadero 收购的 CodeGear 公司的 C++ Builder Community Edition；BloodShed 的 Dev C++ 5 之前的旧版本也不错的，虽有 bug，但在学校学习 C 是够的。Linux 上 KDevelop 和 Geany 也是有不少人用，macOS 上的 XCode 也是可以写 C 的，但更推荐用它写 Swift。&lt;/p&gt;
&lt;p&gt;相比免费的，花钱的 IDE 更自有妙处：如宇宙第一IDE——Visual Studio、IDE中的山王工业 JetBrain CLion，文本编辑器顶流 SublimeText，十年磨一剑的国产文本编辑器 EverEdit，一次付费终身可用的业界良心等，都可以方便的编辑 C 代码。如果对文本编辑器感兴趣，可参考笔者文本编辑器系列文章。&lt;/p&gt;
&lt;h3&gt;C 编译器&lt;/h3&gt;
&lt;p&gt;C 编译器由于和平台耦合，都难跨平台。各大操作系统公司也都有自己的 C++ 编译器，一般在什么平台就用官方的就好。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows 平台：毫无疑问是 MSVC 最棒，需要利用针对 Intel CPU 优化的也有使用 Intel 公司的。GCC 的实现有 MingW 和 Cygwin，Cygwin 需要一个 dll 中间层，MingW 演化为了 MingW64。&lt;/li&gt;
&lt;li&gt;Linux 平台，一般使用 GNU GCC 家族。&lt;/li&gt;
&lt;li&gt;macOS 平台，以前用 GCC，现在用 Clang + LLVM。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一些著名 C 语言编译器，也有人用，比如大学时代使用的命令行界面的 Borland Turbo C，小而快的 Tiny C Compiler，自带 IDE 用于教学的 lcc、Windows 的 Pelles C、Watcom C/ Open Watcom C，小型机的 IBM C Compiler，如果使用 Qt 的话，自带 QtCreator 也是不错，但更 C++。&lt;/p&gt;
&lt;h2&gt;C 更多&lt;/h2&gt;
&lt;h3&gt;C 的思想&lt;/h3&gt;
&lt;p&gt;其实所谓思想，大多是成功后总结出来的，使用了未来函数，参考价值不大。思想是通过细节传播的，C 诞生于 UNIX，可以从学习《UNIX编程环境》开始进入。&lt;/p&gt;
&lt;h3&gt;C 的书籍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《The C Programming Language, Second Edition》, Brian W. Kernighan, Dennis M. Ritchie：你可以一开始就看一遍，能懂多少是多少，接着每隔几年再去读一遍。&lt;/li&gt;
&lt;li&gt;《C 语言程序设计：现代方法》《C Primer Plus》：这两本可以选择一本读就好了，我个人喜欢前者，但也有很多人喜欢后者，其实只是萝卜青菜的问题，它们各自都非常OK。&lt;/li&gt;
&lt;li&gt;《C 和指针》《C 陷阱与缺陷》《C 专家编程》：这三本经常被放在一起提，是因为它们还有其他书籍所不含的东西，去到了其它书没有到过的深度来探讨问题。可以在有实际工作经验后逐步阅读。其中，《C 和指针》非常全面，可以作为复习 C 使用；《C 专家编程》讲述了 C 的历史和设计。&lt;/li&gt;
&lt;li&gt;《编写安全的代码》：这本是微软程序员必读之一&lt;/li&gt;
&lt;li&gt;《代码阅读》：这本讲解了阅读代码的技术，如果学习开源代码觉得很困难，不妨读完这本再出发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;C 参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zh.cppreference.com/w/c"&gt;C 参考手册 - cppreference.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learn.microsoft.com/zh-cn/cpp/c-language/?view=msvc-170"&gt;C 文档 - 入门、教程、参考。 | Microsoft Learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;C 标准：&lt;a href="https://www.open-std.org/JTC1/SC22/WG14/www/standards"&gt;ISO/IEC JTC1/SC22/WG14 - C: Approved standards (open-std.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bell-labs.com/usr/dmr/www/chist.html"&gt;C 历史 (贝尔实验室)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://publications.gbdirect.co.uk//c_book/"&gt;The C Book - Table of Contents (gbdirect.co.uk)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://akaedu.github.io/book/"&gt;Linux C编程一站式学习 (akaedu.github.io)&lt;/a&gt;：许可证是 GFDL &lt;/li&gt;
&lt;li&gt;C-FAQ：可以用作招聘题库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;维基百科 &lt;a href="https://en.wikipedia.org/wiki/C_(programming_language)"&gt;C (programming language) - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;反馈&lt;/h2&gt;
&lt;p&gt;如何你觉得本文有用或有趣，或者相反很想吐槽，或者本文有疏漏，都欢迎在下面留言反馈。&lt;/p&gt;</content><category term="programming"></category><category term="C"></category></entry><entry><title>TCP / UPD Port</title><link href="https://kaffa.im/tcp-port-and-upd-port.html" rel="alternate"></link><published>2023-02-28T12:00:00+08:00</published><updated>2023-02-28T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2023-02-28:/tcp-port-and-upd-port.html</id><summary type="html">&lt;p class="first last"&gt;等闰的那天再填坑。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="catch"&gt;
&lt;h2&gt;Catch!&lt;/h2&gt;
&lt;p&gt;凹，这也许是个永远填不上的坑。 ʕ•̫͡• ʔ•̫͡•ཻʕ•̫͡•ʔ•͓͡•ʔ&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;端口列表&lt;/h2&gt;
&lt;p&gt;很容易找到的端口列表是 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers"&gt;Wiki&lt;/a&gt; 上的。&lt;/p&gt;
&lt;p&gt;但，通过端口来判断服务是非常不准确的。因为只要端口未被占用，完全可以将任何服务设置到任何端口上，甚至多个服务还可以共用端口。&lt;/p&gt;
&lt;p&gt;这一部分内容将在笔者的主题重点移到网络安全时，再继续更新！&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;2024.02.29&lt;/h2&gt;
&lt;p&gt;是的，今天没有更新。&lt;/p&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="TCP Port"></category><category term="UPD Port"></category></entry><entry><title>Markdown 的九个实用语法</title><link href="https://kaffa.im/nine-practical-rules-on-markdown-grammar.html" rel="alternate"></link><published>2021-01-14T12:00:00+08:00</published><updated>2021-01-14T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2021-01-14:/nine-practical-rules-on-markdown-grammar.html</id><summary type="html">&lt;p&gt;本文是 Markdown 实用语法指南，其中列出最常用的九个语法，用来写博客足矣。其余更多细节，请查阅官方指南。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/Markdown"&gt;Markdown&lt;/a&gt; 标记语言的语法是由它的创始人 &lt;a href="https://en.wikipedia.org/wiki/John_Gruber"&gt;John Gruber&lt;/a&gt; 与 &lt;a href="https://en.wikipedia.org/wiki/Aaron_Swartz"&gt;Aaron Swartz&lt;/a&gt; 共同设计的。&lt;/p&gt;
&lt;h2&gt;一、标题&lt;/h2&gt;
&lt;p&gt;标题的代码以&lt;code&gt;#&lt;/code&gt;开头，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;### H3标题
#### H4标题
##### H5标题
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是示例：&lt;/p&gt;
&lt;h3&gt;H3标题&lt;/h3&gt;
&lt;h4&gt;H4标题&lt;/h4&gt;
&lt;h5&gt;H5标题&lt;/h5&gt;
&lt;h2&gt;二、文本样式&lt;/h2&gt;
&lt;p&gt;这是&lt;em&gt;强调&lt;/em&gt;，HTML是&lt;code&gt;&amp;lt;em&amp;gt;强调&amp;lt;/em&amp;gt;&lt;/code&gt;  &lt;br&gt;
这是&lt;strong&gt;加粗&lt;/strong&gt;，HTML是&lt;code&gt;&amp;lt;strong&amp;gt;加粗&amp;lt;/strong&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;文本的代码以以&lt;code&gt;*&lt;/code&gt;或者&lt;code&gt;**&lt;/code&gt;，必须成对出现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;这是*强调*，HTML是`&lt;span class="nt"&gt;&amp;lt;em&amp;gt;&lt;/span&gt;强调&lt;span class="nt"&gt;&amp;lt;/em&amp;gt;&lt;/span&gt;`&lt;span class="w"&gt;  &lt;/span&gt;
这是**加粗**，HTML是`&lt;span class="nt"&gt;&amp;lt;strong&amp;gt;&lt;/span&gt;加粗&lt;span class="nt"&gt;&amp;lt;/strong&amp;gt;&lt;/span&gt;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、段落&lt;/h2&gt;
&lt;p&gt;段落是由空行分割的文字，实际上 md 文件的很多区块都需要换行。&lt;/p&gt;
&lt;p&gt;这是另一个段落P。&lt;/p&gt;
&lt;p&gt;如果希望两段靠在一起。
需要段末尾加入两个空格。&lt;br&gt;
这样就会换行，HTML中间会有&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;段落是由空行分割的文字。&lt;/span&gt;

&lt;span class="err"&gt;这是另一个段落。&lt;/span&gt;

&lt;span class="err"&gt;如果希望两段靠在一起。&lt;/span&gt;
&lt;span class="err"&gt;需要段末尾加入两个空格。这里有两个空格&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="err"&gt;这样就会换行，&lt;/span&gt;&lt;span class="n"&gt;HTML中间会有&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;br&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四、术语表和列表&lt;/h2&gt;
&lt;p&gt;md文件中没有rst文件的术语表，只有有序列表、无序列表&lt;/p&gt;
&lt;p&gt;有序列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有序列表项1&lt;/li&gt;
&lt;li&gt;有序列表项2&lt;/li&gt;
&lt;li&gt;有序列表项3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无序列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序列表项1&lt;/li&gt;
&lt;li&gt;无序列表项2&lt;/li&gt;
&lt;li&gt;无序列表项3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有序列表代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;有序列表项1&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;有序列表项2&lt;/span&gt;
&lt;span class="mf"&gt;3.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;有序列表项3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无序列表代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;*&lt;/span&gt; 无序列表项1
&lt;span class="k"&gt;*&lt;/span&gt; 无序列表项2
&lt;span class="k"&gt;*&lt;/span&gt; 无序列表项3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果希望列表嵌套，那么下级列表要换行，且向内缩进，但无法实现有序编号&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;列表1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;列表1.1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;列表1.1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表1.1.2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表1.2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;列表1&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;列表1&lt;/span&gt;&lt;span class="mf"&gt;.1&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;列表1&lt;/span&gt;&lt;span class="mf"&gt;.1.1&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;列表1&lt;/span&gt;&lt;span class="mf"&gt;.1.2&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;列表1&lt;/span&gt;&lt;span class="mf"&gt;.2&lt;/span&gt;

&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;列表2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;五、代码&lt;/h2&gt;
&lt;p&gt;代码块需整体缩进四个空格。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gh"&gt;#&lt;/span&gt;lang racket                                  ; 声明用 Racket 语言

(define calc
  (lambda (exp)
    (match exp                                ; 分支匹配：表达式的两种情况
      [(? number? x) x]                       ; 是数字，直接返回
      [`(,op ,e1 ,e2)                         ; 匹配提取操作符op和两个操作数e1,e2
       (let ([v1 (calc e1)]                   ; 递归调用 calc 自己，得到 e1 的值
             [v2 (calc e2)])                  ; 递归调用 calc 自己，得到 e2 的值
         (match op                            ; 分支匹配：操作符 op 的 4 种情况
           [&amp;#39;+ (+ v1 v2)]                     ; 如果是加号，输出结果为 (+ v1 v2)
           [&amp;#39;- (- v1 v2)]                     ; 如果是减号，乘号，除号，相似的处理
           [&amp;#39;* (* v1 v2)]
           [&amp;#39;/ (/ v1 v2)]))])))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;六、表格&lt;/h2&gt;
&lt;p&gt;表格属于 Markdown 语法中的扩展语法，扩展语法有很多实现，有些不够统一&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Who&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;Guido&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go&lt;/td&gt;
&lt;td&gt;RRK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;代码如下，为了美观前后可以加上 &lt;code&gt;|&lt;/code&gt; 线：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Who&lt;/span&gt;
&lt;span class="o"&gt;-------&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-------&lt;/span&gt;
&lt;span class="n"&gt;Python&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Guido&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="k"&gt;Go&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RRK&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;Who&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-------&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;--------&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Python&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Guido&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Go&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;RRK&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;七、注释&lt;/h2&gt;
&lt;!-- 这是一条注释，在HTML中将会存在 --&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;!--&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;这是一条注释，在&lt;/span&gt;&lt;span class="n"&gt;HTML中将会存在&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上，&lt;a href="https://daringfireball.net/projects/markdown/syntax"&gt;Markdown语法描述&lt;/a&gt;中没有说明如何写注释，但 md 文件中原生支持插入 HTML 代码。&lt;/p&gt;
&lt;h2&gt;八、超链接&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.markdownguide.org/cheat-sheet/"&gt;markdown cheat-sheet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[markdown cheat-sheet](https://www.markdownguide.org/cheat-sheet/)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者，另一种更优的写法：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.markdowntutorial.com/"&gt;Markdown Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即先在文中任何地方（建议末尾）写上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[7]: https://www.markdowntutorial.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文中即可用下列代码引用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Markdown&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tutorial&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;九、图片&lt;/h2&gt;
&lt;p&gt;图片的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;![请喝咖啡](https://kaffa.im/static/img/reward.png)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果如下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="请喝咖啡" src="https://kaffa.im/static/img/reward.png"&gt;&lt;/p&gt;
&lt;p&gt;感谢阅读！&lt;/p&gt;</content><category term="programming"></category><category term="Markdown"></category></entry><entry><title>P++ 的想法：常见问题（ 全文翻译 ）</title><link href="https://kaffa.im/pplusplus-faq-zh-CN.html" rel="alternate"></link><published>2019-08-12T12:00:00+08:00</published><updated>2019-08-12T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-08-12:/pplusplus-faq-zh-CN.html</id><summary type="html">&lt;p class="first last"&gt;本文《P++ 的想法: 常见问题》是 &lt;a class="reference external" href="https://wiki.php.net/pplusplus/faq"&gt;https://wiki.php.net/pplusplus/faq&lt;/a&gt; 的全文翻译。这是一份对在 internals&amp;#64; 上提出的想法的常见问题澄清，它试图解决许多在随后讨论中被反复提出的问题。1997 年，以色列程序员 Zeev Suraski 及 Andi Gutmans 加入了 Zend 公司 的 PHP 语言开发，发布了 PHP 3, PHP 4, PHP 5，注意没有 PHP 6，再到现在的 PHP 7。 1975 年出生的 Zeev Suraski 在 Zend 工作了 20 年。也许是在语言、架构和库的工作上找不到发展方向了。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="p-1"&gt;
&lt;h2&gt;P++ 的想法: 常见问题&lt;/h2&gt;
&lt;p&gt;原文： &lt;a class="reference external" href="https://wiki.php.net/pplusplus/faq"&gt;https://wiki.php.net/pplusplus/faq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;时间: 2019 年 8 月 9 日&lt;/p&gt;
&lt;p&gt;作者: Zeev Suraski, &lt;a class="reference external" href="mailto:zeev&amp;#64;php.net"&gt;zeev&amp;#64;php.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一份对在 internals&amp;#64;译注1 上提出的想法的常见问题澄清，它试图解决许多在随后讨论中被反复提出的问题。&lt;/p&gt;
&lt;p&gt;注：P++ 是一个临时代码命名，未来可能会变化。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2&gt;这到底是怎么回事？&lt;/h2&gt;
&lt;p&gt;试图将冗长的邮件内容浓缩为几点：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;PHP 世界有两个大的阵营。第一个大致喜欢 PHP 的动态性，带有强烈的 BC译注2 偏见，并特别强调简单性，另一个更喜欢减掉包袱，拥有更高级、更复杂功能的更严格的语言。&lt;/li&gt;
&lt;li&gt;这里没有“对”或“错”。这两种流派都有效，并具有非常坚定的追随者。然而，创建一种同时迎合这两个阵营的语言则是一项挑战，这也是 internals&amp;#64; 上争论的一贯的原因。&lt;/li&gt;
&lt;li&gt;该提议是创建一种新的 PHP 方言（代码名 P++），与 PHP 并存，但不受语言背后的历史哲学约束。换句话说，这种新方言本质上可能更加严格，它可能会更加大胆地消除向后兼容，并删除被认为是“包袱”的元素（例如短标签），并添加更复杂的特性，尤其是那些非常适合严格类型化的语言的，而无需为 PHP 方言引入相同的复杂性。&lt;/li&gt;
&lt;li&gt;这不是 PHP 代码分支。代码库将是同一个，在该代码库上工作的开发人员是相同的。绝大多数代码都是相同的。只有两种方言之间的特定差异点才会有不同的实现。它有点类似于 PHP 7 中的 strict_types 所做的，只是在更大的范围内。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;我们真的要做的就是因为有些人不能放弃短标签吗？&lt;/h2&gt;
&lt;p&gt;这与短标签无关，“弃用短标签 RFC译注3 ”不是这个想法的主要动力。这个提案的目标是更有野心，它是为 PHP 提供一个清晰的愿景，并希望通过向两个阵营提供他们想要的东西来最终解决两方的紧张关系。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php"&gt;
&lt;h2&gt;为什么要分叉 PHP？&lt;/h2&gt;
&lt;p&gt;这不是分叉。 代码库将完全相同，它将由相同的人开发版本。二进制文件将完全相同，如果你安装 PHP，你也将安装 P++，反之亦然。相同的二进制将运行 PHP，P++ 或组合 PHP/P++ 的应用程序。&lt;/p&gt;
&lt;p&gt;虽然目前还不清楚如何将一个文件“标记”为 P++ 文件，但它可能是文件顶部的某种特殊标记，例如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;?p++?&amp;gt;
&amp;lt;?php 'Hello, world!'; ?&amp;gt;
&lt;/pre&gt;
&lt;p&gt;此外，我们可能会找到将整个命名空间标记为 P++ 的方法，因此，框架不必将每个单独的文件明确标记为 P++。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="internals-low"&gt;
&lt;h2&gt;这意味着我们的开发工作量增加了一倍，而 internals&amp;#64; 的贡献者已经很低（low）了。 我们如何处理？&lt;/h2&gt;
&lt;p&gt;值得庆幸的是，这并不意味着是那样（工作量增加了一倍）。绝大多数代码将在 PHP 模式和 P++ 模式之间共享——包括源代码和运行时。&lt;/p&gt;
&lt;p&gt;无论运行的文件是 PHP 还是 P++文件，数据结构、关键子系统、扩展、Web服务器接口、OPcache 以及其他所有代码都将是完全相同的代码。唯一的额外开发开销会是 PHP 和 P++ 之间的差异部分。&lt;/p&gt;
&lt;p&gt;确实，这意味着我们必须维护某些代码片段的两个版本，并且我们在各个地方都会有一些 if() 语句，因为与 PHP 相比，P++ 可能会有额外的检查。 但是，如果我们要转向更严格的 PHP 版本，这些元素无论如何都必须引入。此外，即使是严格阵营中的人，也不建议我们在没有提供迁移途径的情况下转向未来严格版本——实际上，这种方法所涉及的努力和几乎任何其他的方法都是相似的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php-8-9-php-7-4"&gt;
&lt;h2&gt;当我们转向更严格的 PHP 8/9时， 为什么不只是开发一个永久维护的 PHP 7.4 长期维护版？&lt;/h2&gt;
&lt;p&gt;这种方法存在许多问题。 即使我们忽视这样一个事实，即这会让庞大的动态偏好阵营悬而未决——没有任何特性或性能更新，从开发工作的角度来看，这是不切实际的。 这与这个提议不同，事实上，这确实意味着事实上的分叉。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php-p"&gt;
&lt;h2&gt;我需要在 PHP 和 P++ 之间做出选择吗？&lt;/h2&gt;
&lt;p&gt;是，也不是。 如上所述，当你安装一个，你就有了另一个，所以就应用而言，你可以在一台服务器上运行这两种方言。 然而，实际上，项目和个人通常可能选择并标准化其中一个，类似于严格类型的情况。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php-p-1"&gt;
&lt;h2&gt;我能在同一个应用程序中混合使用 PHP 和 P++ 吗？&lt;/h2&gt;
&lt;p&gt;是的。 虽然我们需要确定精确的机制，但代码是 PHP 还是 P++ 的指定将在文件级别，而不是在请求级别。 单个执行（请求）可以加载许多不同的文件，这些文件可以来自两种方言。PHP文件中的代码将表现为 PHP 语义——而来自 P++ 文件的代码将表现为 P++ 语义。 这也是，与 strict_types 类似。&lt;/p&gt;
&lt;p&gt;虽然这开始听起来可能听很尴尬，但可能会有非常实用的用例。例如，PHP 应用程序使用的只含 P++ 的框架，反之亦然。 对于那些熟悉 C 和 C++ 的人来说，这有点类似。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php-p-2"&gt;
&lt;h2&gt;这是否意味着 PHP 将不再发展？ 所有新功能都会用于 P++ 吗？&lt;/h2&gt;
&lt;p&gt;不，这只是意味着它会以不同的方式发展。 严格性和类型相关的功能可能只适用于 P++，并且只能在 P++ 文件中使用。向后兼容偏差将保留在 PHP 中（这并不意味着向后兼容永不会被打破，只是每个这样的案例必须有良好的投资回报案例）。&lt;/p&gt;
&lt;p&gt;但是，与此无关的功能，例如引擎的性能改进（如 JIT ），扩展的开发，或新的异步相关的功能，PHP 和 P++ 都可以使用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;这个方法有什么好处？&lt;/h2&gt;
&lt;p&gt;这种方法有很多好处。 首先，它为 internals&amp;#64; 的两个阵营提供了一个很好的解决方案。 那些喜欢 PHP 动态特性的人可以保留它，而那些喜欢更严格类型语言的人也可以获得它，而不受任何 PHP 限制。 而替代方案是零和游戏，一个阵营的胜利是另一个的失败，反之亦然。&lt;/p&gt;
&lt;p&gt;除了设计一个好的技术解决方案（使我们能够以最少的努力支持整个受众）之外，还可以终结近年来 internals&amp;#64; 上争论的关键根源。&lt;/p&gt;
&lt;p&gt;最后，虽然本文档的大多数读者可能是技术人员，但应该注意的是，启动 P++ 将从一个新的基点译注4不计过去重新开始，可能具有巨大的定位和品牌优势。未使用 PHP 的公司、开发经理和个人开发者更有可能注意到 P++ 的推出，而不是 PHP 8.0 或 PHP 9.0 的推出。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;我们不是冒着分裂用户群的风险吗？&lt;/h2&gt;
&lt;p&gt;在某种程度上，我们是。但这不是这一想法的缺陷， 而是现实已经存在的表现。&lt;/p&gt;
&lt;p&gt;如上所述，那里有很多人喜欢 PHP 的动态本质，并且谨慎地看待尝试使其越来越多地面向类型。&lt;/p&gt;
&lt;p&gt;与此同时，还有另外一群看着 PHP 的人，自己在想：“为什么它变得如此缓慢，以至于我最终要放弃这动态的废材（原文：dynamic nonsense）？”&lt;/p&gt;
&lt;p&gt;这里没有对或错。这两种观点都有效。当我们研究在这两个相互矛盾的观点之间架起桥梁的可能的解决方案时，没有太多可用的方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;坚持使用动态PHP。这将不会被更严格语言的支持者所接受。&lt;/li&gt;
&lt;li&gt;向严格的PHP发展。动态语言的支持者不会接受这一点。&lt;/li&gt;
&lt;li&gt;分叉代码库。无论如何完成，都是所有参与者的净损失选项。 这样做没有技术优势，即使我们想要（我们不想要），我们也没有足够的贡献者去做。&lt;/li&gt;
&lt;li&gt;提出一些创意解决方案，以满足双方观众的需求。 这就是该提案试图做的。它在保持项目本身统一的同时，也确保两种方言之间的永久互操作性。这虽然会有一定程度的碎片化，但它仍然是满足每个人的主要需求的最小可能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="nikita5"&gt;
&lt;h2&gt;这与 Nikita译注5 版本的想法有何不同？&lt;/h2&gt;
&lt;p&gt;这两个想法之间有许多相似之处，但也存在一些实质性差异。 请注意，这是基于对版本方法的有限理解，因此部分可能缺乏，不准确或不正确。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;在这个提议中，有一个明确的目标是保持当前动态类型的 PHP，作为一个长期的，完全支持的，平等的对等方言。 发版本的方法将当前行为视为“遗留”。 这意味着它可能会被劝止（使用），然后在某些时候弃用和删除。&lt;/li&gt;
&lt;li&gt;推出策略完全不同。 P++ 提案旨在首先关注兼容性破坏元素，例如严格的操作、类型转换逻辑的更改、数组索引处理、需要变量声明等等，并且旨在在 P++ 的第一期提供它们。这样做的目的是允许新项目/框架重新开始，而不需知道在引入更多兼容性更改时，他们可能不得不在一两年内进行重大改写。 版本化提案似乎没有这样的目标，而是旨在逐步添加/更改 PHP 中的元素。&lt;/li&gt;
&lt;li&gt;与推出方式相关，版本化方法不允许只有两种方言，而是任何数量的方言。我们可能有 PHP2020 方言，以及 PHP2022 方言和 PHP2027 方言。 如果我们全部保留它们，实际上这可能会增加我们的维护复杂性。&lt;/li&gt;
&lt;li&gt;该提议还提到了 PHP 与 P++（保守与积极）的不同打破向后兼容策略，而版本化方案可能根本不会涉及该主题。&lt;/li&gt;
&lt;li&gt;版本提案与此提案的定位/营销方面并不完全相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重要的是，要注意这两个想法不一定是相互排斥的。 我们可以介绍 P++ 并使用版本进行改进，特别是当证明很难将所有重要的变化都放到 P++ 的第一期中。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2&gt;有哪些挑战？&lt;/h2&gt;
&lt;p&gt;在我们能运行第一个 P++ 应用程序之前，不乏挑战。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;我们需要获得支持。这意味着，两派的人都需要放弃让 PHP 完全动态或完全类型化的梦想，而忽略那些与他们想法不同的人。这似乎是一个非常重大的挑战。&lt;/li&gt;
&lt;li&gt;为获得成功，P++ 第一个版本应该处理来自 PHP 的所有，或至少大多数兼容性破坏的更改，以便切换（可能相当痛苦）的开发人员不必在未来重新审核/彻底重构他们的代码。一些人表示担心，由于我们的开发人员能力有限，他们可能过于乐观，无法在一期发布。一旦我们对列表的内容有了更好的了解，我们就必须对此进行评估。 请注意，这并不意味着我们需要在第一个期中实现我们可能对 P++ 提出的所有想法，只是我们应该优先考虑会触发大量最终用户代码重写的元素，并尝试在我们的第一版之前处理它们。&lt;/li&gt;
&lt;li&gt;当然,最具挑战性的——我们需要为这种新方言找到一个合理的名字。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pplusplus/faq.txt · 最后修改： zeev 于 2019/08/09 21:44&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2&gt;译注&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;internals&amp;#64;：PHP 内部开发人员邮件列表。这里涉及 PHP 的开发机制，当内部讨论成熟后，会公开在 externals，通常用来提交 RFC 和发布版本通知。&lt;/li&gt;
&lt;li&gt;BC：即 Backward Compatibility，向后兼容，也叫向下兼容，兼容过去的版本，即升级的软件要考虑旧版本的兼容性，比如，Office 2019 的 Word 默认使用 .docx 文件格式，但也可以打开 Office 2017/2013/2010，甚至是 2003 的 .doc 格式。相对的概念叫做 FC，即 Forward Compatibility，向前兼容，也叫向上兼容，即升级的软件会考虑对未来的兼容性。这在软件中通常为一个确定的接口和约定，未来依然遵循，即可实现向前兼容。&lt;/li&gt;
&lt;li&gt;RFC：即 Request for Comments，语言特性的加入，以及标准化变更管理的方法，通常加入新特性时，会为新特性提交 RFC 并给出例子，变更委员会评估通过后，语言会合入实现的源码，并入新版本。&lt;/li&gt;
&lt;li&gt;新的基点：a clean slate，美国习语，即不计过去新的开始。&lt;/li&gt;
&lt;li&gt;Nikita：一位 internals&amp;#64; 上的发言者，提议在版本中加入特性。顺便提一句，美剧《Nikita》值得一看。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（本文翻译为笔者原创 ，限于水平有限，如翻译中有不妥的地方请回复留言，如转载请注明出处：IT桃花岛）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2&gt;相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://kaffa.im/php-zeev-resigned-originally-he-wanted-to-start-pplusplus.html"&gt;PHP 联席架构师辞职，原来他想做 P++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/static/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="P++"></category></entry><entry><title>reStructuredText 九个实用语法</title><link href="https://kaffa.im/nine-restructuredtext-grammar.html" rel="alternate"></link><published>2019-07-25T12:00:00+08:00</published><updated>2023-11-09T20:50:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-07-25:/nine-restructuredtext-grammar.html</id><summary type="html">&lt;p class="first last"&gt;本文记录了 reStructuredText 九个实用语法，顺便吐槽了 Markdown。对于绝大多数人来说，Markdown 够用了，对于不够用的人可以参考 reStructuredText，它有一些 Markdown 不具备的优点，整体来说，语法更统一严谨一些，很适合用来写技术笔记，学起来也简单。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="restructuredtext-1"&gt;
&lt;h2&gt;reStructuredText 是什么&lt;/h2&gt;
&lt;p&gt;reStructuredText 是一种轻量级的文本标记语言，是 Python 中 Docutils 项目的一部分。其文件以 .rst 为后缀，也常被简写为 rst 或 reST。它可以被转化成 PDF、HTML 等多种格式，也可以由 Sphinx 转化为 LaTex、man 等格式，现被广泛的用于开源程序文档的撰写。&lt;/p&gt;
&lt;p&gt;本文记录了其常用语法，整体来说，语法更统一严谨一些，很适合用来写技术笔记，学起来也简单。在计算机上写作的人，如果不满意 Markdown 的缺点，也可使用它来替代。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rst"&gt;
&lt;h2&gt;rst 语法指南&lt;/h2&gt;
&lt;p&gt;官方参考细致繁复，对初学者不够友好。若要拿着 reStructuredText 写文章，仅需先知晓写文章的简单实用语法，本文已列出最常用的九个语法。&lt;/p&gt;
&lt;div class="notification is-info is-light"&gt;
    &lt;i class="fa fa-info-circle mr-3" aria-hidden="true"&gt;&lt;/i&gt;
    可参看官方参考：https://docutils.sourceforge.io/rst.html
&lt;/div&gt;&lt;div class="section" id="section-1"&gt;
&lt;h3&gt;一、文本样式&lt;/h3&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
*斜体*

**粗体**

``段内标记``
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;p class="first"&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt;&lt;/p&gt;
&lt;p class="last"&gt;&lt;tt class="docutils literal"&gt;段内标记&lt;/tt&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3&gt;二、标题&lt;/h3&gt;
&lt;p&gt;rst 的主场是写书和写文档，可参用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;#*=-^&amp;quot;&lt;/span&gt;&lt;/tt&gt; 符号&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;#&lt;/tt&gt;, parts，部分，比如一本书的“第一部分”&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;*&lt;/tt&gt;, chapters，章，比如“第一章”&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;=&lt;/tt&gt;, sections，节，比如“第一节”&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;-&lt;/tt&gt;, subsections，小节，比如“第一小节”&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;^&lt;/tt&gt;, subsubsections，小小节，中文书少用。&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&amp;quot;&lt;/tt&gt;, paragraphs，段落。&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
第 1 章 标题
======================

第 1.1 节 标题
--------------------

第 1.1.1 小节 标题
^^^^^^^^^^^^^^^^^^^^^^

第 1.1.2 小节 标题
^^^^^^^^^^^^^^^^^^^^^^

第 1.2 节 标题
--------------------

第 2 章 标题
======================

第 2.1 节 标题
--------------------

第 2.1.1 小节 标题
^^^^^^^^^^^^^^^^^^^^^^

第 2.1.2 小节 标题
^^^^^^^^^^^^^^^^^^^^^^

第 2.2 节 标题
--------------------
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;div class="first last"&gt;&lt;div class="section"&gt;
    &lt;h2&gt;第 1 章 标题&lt;/h2&gt;
    &lt;div class="section"&gt;
        &lt;h3&gt;第 1.1 节 标题&lt;/h3&gt;
        &lt;div class="section"&gt;
            &lt;h4&gt;第 1.1.1 小节 标题&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class="section"&gt;
            &lt;h4&gt;第 1.1.2 小节 标题&lt;/h4&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="section"&gt;
        &lt;h3&gt;第 1.2 节 标题&lt;/h3&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="section"&gt;
    &lt;h2&gt;第 2 章 标题&lt;/h2&gt;
    &lt;div class="section"&gt;
        &lt;h3&gt;第 2.1 节 标题&lt;/h3&gt;
        &lt;div class="section"&gt;
            &lt;h4&gt;第 2.1.1 小节 标题&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class="section"&gt;
            &lt;h4&gt;第 2.1.2 小节 标题&lt;/h4&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="section"&gt;
        &lt;h3&gt;第 2.2 节 标题&lt;/h3&gt;
    &lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="notification is-warning is-light"&gt;
    注意：rst 输出网页中只允许有一个一级标题，且标题的层次不能前后矛盾，否则输出时会报错：Title level inconsistent
&lt;/div&gt;

&lt;div class="notification is-info is-light"&gt;
    如果在 VSCode 中预览标题遇到问题，可参阅我另一篇
    &lt;a href="https://kaffa.im/preview-restructuredtext-file-in-vscode.html" target="_blank"&gt;用 VSCode 预览 reStructuredText 文件&lt;/a&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3&gt;三、段落&lt;/h3&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;rst 标记&lt;/th&gt;
&lt;th class="head" colspan="2"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;pre class="first last literal-block"&gt;
段落是由空行分割的文字。

这是另一个段落。
&lt;/pre&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;p class="first"&gt;段落是由空行分割的文字。&lt;/p&gt;
&lt;p class="last"&gt;这是另一个段落&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3&gt;四、列表和术语表&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;无序列表&lt;/li&gt;
&lt;/ol&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;rst 标记&lt;/th&gt;
&lt;th class="head" colspan="2"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;pre class="first last literal-block"&gt;
* 这是一个无序列表
* 它含有两项，第二
  项占两行
&lt;/pre&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;这是一个无序列表&lt;/li&gt;
&lt;li&gt;它含有两项，第二
项占两行&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;有序列表&lt;/li&gt;
&lt;/ol&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;rst 标记&lt;/th&gt;
&lt;th class="head" colspan="2"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;pre class="first last literal-block"&gt;
1. 这是一个有序列表
2. 它也有两项
&lt;/pre&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;这是一个有序列表&lt;/li&gt;
&lt;li&gt;它也有两项&lt;/li&gt;
&lt;/ol&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;多级列表&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="notification is-danger is-light"&gt;
    此特性可让 reStructuredText 持续嘲讽 Markdown
&lt;/div&gt;&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;rst 标记&lt;/th&gt;
&lt;th class="head" colspan="2"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;pre class="first last literal-block"&gt;
* 这是
* 一个多级列表

  * 含一个缩进子列表
  * 这是子列表另一个子项
* 这里是父级的继续
&lt;/pre&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;这是&lt;/li&gt;
&lt;li&gt;一个多级列表&lt;ul&gt;
&lt;li&gt;含一个缩进子列表&lt;/li&gt;
&lt;li&gt;这是子列表另一个子项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这里是父级的继续&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="24%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head" colspan="2"&gt;rst 标记&lt;/th&gt;
&lt;th class="head" colspan="2"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td colspan="2"&gt;&lt;pre class="first last literal-block"&gt;
* 这是更复杂的情况
* 一个含无序列表和有序列表的多级列表
* 混合无序列表和有序列表

    1. 含一个缩进列表子项
    2. 和另一个子项

      * 及另一个第一子项
      * 和第二子项
* 这里是父级的继续
&lt;/pre&gt;
&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;这是更复杂的情况&lt;/li&gt;
&lt;li&gt;一个含无序列表和有序列表的多级列表&lt;/li&gt;
&lt;li&gt;混合无序列表和有序列表&lt;ol class="arabic"&gt;
&lt;li&gt;含一个缩进列表子项&lt;/li&gt;
&lt;li&gt;和另一个子项&lt;ul&gt;
&lt;li&gt;及子项的第一子项&lt;/li&gt;
&lt;li&gt;和第二子项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;这里是父级的继续&lt;/li&gt;
&lt;/ul&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;术语表&lt;/li&gt;
&lt;/ol&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
术语一
    术语解释，需要缩进。

    甚至可以有多个段落。

术语二
    描述
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;dl class="first last docutils"&gt;
&lt;dt&gt;术语一&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;术语解释，需要缩进&lt;/p&gt;
&lt;p class="last"&gt;甚至可以有多个段落&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;术语二&lt;/dt&gt;
&lt;dd&gt;描述&lt;/dd&gt;
&lt;/dl&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;五、代码&lt;/h3&gt;
&lt;p&gt;双冒号换行两次后缩进就是代码。&lt;/p&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
::

    # PEP 20 -- The Zen of Python
    import this
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;pre class="first last literal-block"&gt;
# PEP 20 -- The Zen of Python
import this
&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;六、表格&lt;/h3&gt;
&lt;p&gt;简易写法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
=====  =====  =======
A      B      A and B
=====  =====  =======
False  False  False
True   False  False
False  True   False
True   True   True
=====  =====  =======
&lt;/pre&gt;
&lt;p&gt;显示为：&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="29%" /&gt;
&lt;col width="29%" /&gt;
&lt;col width="41%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;A&lt;/th&gt;
&lt;th class="head"&gt;B&lt;/th&gt;
&lt;th class="head"&gt;A and B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;单元格也支持格式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+--------------------+--------------------+
| rst 代码           | 显示               |
+====================+====================+
|::                  |                    |
|                    |                    |
| *斜体*             |*斜体*              |
| **粗体**           |**粗体**            |
| ``段内标记``       |``段内标记``        |
|                    |                    |
+--------------------+--------------------+
&lt;/pre&gt;
&lt;p&gt;显示为：&lt;/p&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 代码&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
*斜体*
**粗体**
``段内标记``
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;em&gt;斜体&lt;/em&gt;
&lt;strong&gt;粗体&lt;/strong&gt;
&lt;tt class="docutils literal"&gt;段内标记&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合并单元格也支持:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+--------------------+--------------------+--------------------+
| 标题1              | 标题2              | 标题3              |
+====================+====================+====================+
| 行1列1             |            行1列2 与 行1列3 合并        |
+--------------------+--------------------+--------------------+
| 行2列1             | 行2列2             | 行2列3             |
+--------------------+ 与                 +--------------------+
| 行3列1             | 行3列2 合并        | 行3列3             |
+--------------------+--------------------+--------------------+
| 行4列1             | 行4列2             | 行4列3             |
|                    |                    |                    |
+--------------------+--------------------+--------------------+
&lt;/pre&gt;
&lt;p&gt;显示为：&lt;/p&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="24%" /&gt;
&lt;col width="49%" /&gt;
&lt;col width="27%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;标题1&lt;/th&gt;
&lt;th class="head"&gt;标题2&lt;/th&gt;
&lt;th class="head"&gt;标题3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;行1列1&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;strong&gt;行1列2 与 行1列3 合并&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;行2列1&lt;/td&gt;
&lt;td rowspan="2"&gt;行2列2
与
行3列2 合并&lt;/td&gt;
&lt;td&gt;行2列3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;行3列1&lt;/td&gt;
&lt;td&gt;行3列3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;行4列1&lt;/td&gt;
&lt;td&gt;行4列2&lt;/td&gt;
&lt;td&gt;行4列3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;甚至可给单元格加上 class:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
.. class:: table is-bordered

    +--------------------+-----------------------------------------+----------------------+
    | 标题1              | 标题2                                   | 标题3                |
    +====================+=========================================+======================+
    |                    |.. class:: highlight-cell-1                                     |
    |                    |                                                                |
    | 行1列1             | **行1列2 与 行1列3 合并**                                      |
    |                    |                                                                |
    +--------------------+-----------------------------------------+----------------------+
    |                    |.. class:: highlight-cell-2              |                      |
    |                    |                                         |                      |
    | 行2列1             | 行2列2                                  | 行2列3               |
    +--------------------+ 与                                      +----------------------+
    | 行3列1             | 行3列2 合并                             | 行3列3               |
    +--------------------+-----------------------------------------+----------------------+
    | 行4列1             | 行4列2                                  | 行4列3               |
    |                    |                                         |                      |
    +--------------------+-----------------------------------------+----------------------+

.. raw:: html

   &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
   &amp;lt;script&amp;gt;
       $(function() {
           $('.highlight-cell-1').parent().addClass('has-background-success-light');
           $('.highlight-cell-2').parent().addClass('has-background-danger-light');
       });
   &amp;lt;/script&amp;gt;
&lt;/pre&gt;
&lt;p&gt;显示为：&lt;/p&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="http://kaffa.im/static/js/jquery-3.7.1.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
    $(function() {
        $('.highlight-cell-1').parent().addClass('has-background-success-light');
        $('.highlight-cell-2').parent().addClass('has-background-danger-light');
    });
&lt;/script&gt;&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="24%" /&gt;
&lt;col width="49%" /&gt;
&lt;col width="27%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;标题1&lt;/th&gt;
&lt;th class="head"&gt;标题2&lt;/th&gt;
&lt;th class="head"&gt;标题3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;行1列1&lt;/td&gt;
&lt;td colspan="2"&gt;&lt;p class="highlight-cell-1 first last"&gt;&lt;strong&gt;行1列2 与 行1列3 合并&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;行2列1&lt;/td&gt;
&lt;td rowspan="2"&gt;&lt;p class="highlight-cell-2 first last"&gt;行2列2
与
行3列2 合并&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;行2列3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;行3列1&lt;/td&gt;
&lt;td&gt;行3列3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;行4列1&lt;/td&gt;
&lt;td&gt;行4列2&lt;/td&gt;
&lt;td&gt;行4列3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="notification is-primary is-light"&gt;
    reStructuredText 可谓极大做到了代码和显示都能看。
&lt;/div&gt;&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;七、注释&lt;/h3&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
注释例子
..
    这个缩进
    是一个注释。

    同级依然是注释
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;p class="cell-3 first last"&gt;注释例子&lt;/p&gt;
&lt;!-- 这个缩进
是一个注释。

同级依然是注释 --&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="notification is-success is-light"&gt;
    &lt;span class="block"&gt;上方表格右侧单元格的 HTML 源代码中会含有以下注释&lt;/span&gt;
    &lt;button class="block" onclick="javascript: alert(
        '&lt;!-- '
        + $('.cell-3')[0].nextSibling.nextSibling.nodeValue
        + ' --&gt;');"&gt;点击验证&lt;/button&gt;

    &lt;pre&gt;
        &amp;lt;!-- 这个缩进
        是一个注释。

        同级依然是注释 --&amp;gt;
    &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;八、超链接&lt;/h3&gt;
&lt;p&gt;嵌入式链接&lt;/p&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
`链接 &amp;lt;https://kaffa.im/&amp;gt;`_
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;a class="reference external" href="https://kaffa.im/"&gt;链接&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;引用式链接&lt;/p&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
这段含有一个 `链接`_。

这段也含有这个 `链接`_。

.. _`链接`: https://kaffa.im/
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;p class="first"&gt;这段含有一个 &lt;a class="reference external" href="https://kaffa.im/"&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;p class="last"&gt;这段也含有这个 &lt;a class="reference external" href="https://kaffa.im/"&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="notification is-success is-light"&gt;
    链接的定义行，如「 .. _`链接`: https://kaffa.im/ 」可放在文档任意位置，习惯上，统一放在文末便于管理。
&lt;/div&gt;

&lt;div class="notification is-danger is-light"&gt;
    在实际的使用中，使用引用式链接中文的链接左右各需要有一个空格。
&lt;/div&gt;&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h3&gt;九、图片&lt;/h3&gt;
&lt;table border="1" class="table is-bordered docutils"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;rst 标记&lt;/th&gt;
&lt;th class="head"&gt;显示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;pre class="first last literal-block"&gt;
.. image:: https://kaffa.im/static/img/reward.png
    :alt: 打赏用我，感谢阅读。
&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;&lt;img alt="打赏用我，感谢阅读。" class="first last" src="https://kaffa.im/static/img/reward.png" /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h2&gt;补充技巧&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;带删除线的文字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class="strike"&gt;删除的&lt;/span&gt; 文字&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;不留白的写法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不留白的&lt;span class="strike"&gt;删除的&lt;/span&gt;文字&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;上下标&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;水的分子式: H&lt;sub&gt;2&lt;/sub&gt;O
质能转化方程：E = mc&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h2&gt;附录：我用过文本标记语言&lt;/h2&gt;
&lt;p&gt;互联网写作的河流中，流过许多标记语言，很难说哪些标记语言有压倒性的优势。&lt;/p&gt;
&lt;p&gt;它们主要是创作者们为解决书写和排版格式的差异问题，这里的努力集中在——写作者们希望，用最小的代码实现源码和输出格式兼具可读性。&lt;/p&gt;
&lt;p&gt;除开我们熟悉 HTML 和 XML，我使用的几种轻量级的主流都是在 2000 年后成熟或出现的：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Org Mode&lt;/strong&gt;: in 2003 by Carsten Dominik&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AsciiDoc&lt;/strong&gt;: in 2002 by Stuart Rackham&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Textile&lt;/strong&gt;: in 2002 by Dean Allen&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reStructuredText&lt;/strong&gt;: in 2001 by David Goodger&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt;: in 2004 by John Gruber&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Org Mode 是文本生活倡导者首选，也是 Emacs &lt;a class="footnote-reference" href="#f1" id="footnote-reference-1"&gt;[1]&lt;/a&gt; 忠实爱好者的选择；AsciiDoc 想的是“人类可读”还可以发布为文档格式；Textile 的缺点和优势是可以混入简单的样式，它使用 PHP 实现，伴有一个设计精巧的 TextPattern CMS，源码有充分的单元测试，但其社区不大；而 reStructuredText 更宏大不断演化而来，吸收了 Zope、Setext、Javadoc 的设计，是这些文档格式中最严谨和包容并蓄的，被广大开源社区偏爱；但从使用广泛来说，这些都在近十年都被 Markdown 超越了。&lt;/p&gt;
&lt;p&gt;Markdown 这种标记语言的语法，最早是一名科技作家 John Gruber 设计的，他的设计初衷是使人们能使用易于阅读和编写的纯文本格式进行编写，还可以选择将其转换为结构有效的 HTML，于是他在 BBEdit 编辑器中实现了它。&lt;/p&gt;
&lt;p&gt;但说 Markdown 的走红，背后还有参与其中的天才 Aaron Swartz 的原因，&lt;strong&gt;一位不策划社会政治活动的企业家黑客不是好的程序员&lt;/strong&gt; 可以较准确的描述 Aaron，他为今天的 Web 写作行为提供了许多的核心工具，比如 RSS 标准，更好的订阅、分享和推送内容，CC 协议，中文写作者熟悉的《创作者共用》协议，确保了内容的创作共享，web.py 诠释了 Python 的 KISS 哲学。我也读过 Aaron 不少文章，其逻辑清晰，表示准确简洁，易于传播，等今后有空会写一篇他做过的传奇事迹的笔记。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="markdown"&gt;
&lt;h2&gt;Markdown 的槽点&lt;/h2&gt;
&lt;p&gt;如果我们将这些标记语言的演化看成是公司的发展，则可以思考它们都做对了什么和哪里做的不够。Markdown 发布了二十多年，目前，对于绝大多数人写作的常规需求来说，Markdown 够用，但如果你没有使用以下功能的话：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;列表嵌套&lt;/li&gt;
&lt;li&gt;代码渲染&lt;/li&gt;
&lt;li&gt;文档元数据&lt;/li&gt;
&lt;li&gt;书籍写作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Markdown 中，至少上述功能各方实现常不一致。尤其是第一点。&lt;/p&gt;
&lt;p&gt;例如，如下无序列表中含有有序列表。&lt;/p&gt;
&lt;p&gt;一、“文本形式”说：我所见即所得:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* 年
* 月
* 周
  1. 星期一
  2. 星期二
  3. 星期三
  4. 星期四
  5. 星期五
  6. 星期六
  7. 星期日
* 日
&lt;/pre&gt;
&lt;p&gt;二、“HTML”说：这有啥特别的吗？&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;年&lt;/li&gt;
&lt;li&gt;月&lt;/li&gt;
&lt;li&gt;周&lt;ol class="arabic"&gt;
&lt;li&gt;星期一&lt;/li&gt;
&lt;li&gt;星期二&lt;/li&gt;
&lt;li&gt;星期三&lt;/li&gt;
&lt;li&gt;星期四&lt;/li&gt;
&lt;li&gt;星期五&lt;/li&gt;
&lt;li&gt;星期六&lt;/li&gt;
&lt;li&gt;星期日&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;日&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其代码是在 HTML 中用 ol 包含 ul 实现:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;ol&amp;gt;
    &amp;lt;li&amp;gt;年&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;月&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;周&amp;lt;/li&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;星期一&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;星期二&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;星期三&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;星期四&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;星期五&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;星期六&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;星期日&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;li&amp;gt;日&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/pre&gt;
&lt;p&gt;三、“reStructuredText”说：支持列表嵌套是我的特性之一，轻松实现，其代码是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* 年
* 月
* 周
  1. 星期一
  2. 星期二
  3. 星期三
  4. 星期四
  5. 星期五
  6. 星期六
  7. 星期日
* 日
&lt;/pre&gt;
&lt;p&gt;四、“Org mode” 更是说：我轻松支持 + - * 三级列表呢:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+ 年
+ 月
+ 周
  1. 星期一
  2. 星期二
  3. 星期三
  4. 星期四
  5. 星期五
  6. 星期六
  7. 星期日
+ 日
&lt;/pre&gt;
&lt;p&gt;五、Textile 表示，这是我的基本操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* 年
* 月
* 周
## 星期一
## 星期二
## 星期三
## 星期四
## 星期五
## 星期六
## 星期日
* 日
&lt;/pre&gt;
&lt;p&gt;六、Markdown 写下如下代码，但输出却搞砸了。它沉默了一会说：等等，我得看看代码……&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* 年
* 月
* 周

  1. 星期一
  2. 星期二
  3. 星期三
  4. 星期四
  5. 星期五
  6. 星期六
  7. 星期日

* 日
&lt;/pre&gt;
&lt;p&gt;所以这里的槽点就是，很多使用很久东西从设计之初就决定了走向。当调整 Markdown 格式的细节，常费时费力，有一种梦回 2000 年旧时代的感觉，我与含有缺陷的排版软件相处的日子，比如用内置模板错乱的 Word 写文档时的感觉，累觉无爱。&lt;/p&gt;
&lt;p&gt;相比来说我选择退回到 reStructuredText，它虽然更复杂，但却严谨丰富，作为 Python 世界的主格式，Pelican 引擎的动力之一，我对 reStructuredText 的基本态度是“一直能打”，综合比较，我放弃了 md 转回了 rst。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rst-1"&gt;
&lt;h2&gt;😁 补充 rst 图片的语法&lt;/h2&gt;
&lt;p&gt;可以给图片加上属性:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
.. image:: https://kaffa.im/static/img/reward.png
    :height: 200
    :width: 200
    :scale: 50
    :alt: 打赏专用，感谢阅读。
&lt;/pre&gt;
&lt;p&gt;显示效果如图&lt;/p&gt;
&lt;img alt="打赏专用，感谢阅读。" src="https://kaffa.im/static/img/reward.png" style="width: 200px; height: 200px;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="section-12"&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;table class="docutils footnote" frame="void" id="f1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Emacs：等有空，会完成 &lt;a class="reference external" href="http://kaffa.im/emacs.html"&gt;Emacs&lt;/a&gt; 专辑给大家讲解...&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="reStructuredText"></category></entry><entry><title>悟了，你所需要的最后一篇部署指南</title><link href="https://kaffa.im/the-last-installation-and-deployment-guide-you-need.html" rel="alternate"></link><published>2019-06-06T12:00:00+08:00</published><updated>2024-02-28T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-06-06:/the-last-installation-and-deployment-guide-you-need.html</id><summary type="html">&lt;p class="first last"&gt;这篇是在约5年前我在朋友的公司为客户部署一套 OpenStack 时的笔记，五年后，我在修改中删除了 80% 内容，这就是技术文档。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="section-2"&gt;
&lt;h2&gt;图片版权&lt;/h2&gt;
Photo by &lt;a href="https://unsplash.com/@markuswinkler?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash"&gt;Markus Winkler&lt;/a&gt; on &lt;a href="https://unsplash.com/photos/white-paper-on-brown-folder-beside-silver-key-92HqQ0ZvKDA?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash"&gt;Unsplash&lt;/a&gt;&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2&gt;题记&lt;/h2&gt;
&lt;img alt="OpenStack" src="https://kaffa.im/static/img/2019/openstack-logo-full.png" style="width: 25%;" /&gt;
&lt;pre class="literal-block"&gt;
如果你爱一个人，送他去部署 OpenStack，因为那里是天堂；
如果你恨一个人，送他去部署 OpenStack，因为那里是地狱。
&lt;/pre&gt;
&lt;p&gt;OpenStack 是在一个“大帐篷”，之下的相互协同的IT基础设施有关的开源项目组合。&lt;/p&gt;
&lt;p&gt;如果你成功的部署并使用它，则可以赋予你云的管理能力。&lt;/p&gt;
&lt;p&gt;如果你用尽各种办法部署 OpenStack，遇到了各种障碍，还没放弃搜索，那我希望你搜索到此篇。&lt;/p&gt;
&lt;p&gt;我将在此篇传授你《万物部署指南》，the last guides you need.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2&gt;说“最后一篇”的底气是什么？&lt;/h2&gt;
&lt;p&gt;&lt;span class="strike"&gt;因为这个部署方式是相当清晰的、各个击破的、非常详尽的，它记录了每一个步骤，经过了反复测试，甚至修正了官方部署中的瑕疵。所以敢说：按此部署，一定成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你没有成功，&lt;span class="strike"&gt;还可在本文回复留言，我会来答疑，&lt;/span&gt;请继续阅读。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="openstack"&gt;
&lt;h2&gt;OpenStack 部署步骤&lt;/h2&gt;
&lt;img alt="OpenStack 2023.2" src="https://kaffa.im/static/img/2024/openstack-installation.png" /&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3&gt;目的和范围&lt;/h3&gt;
&lt;p&gt;本节讲述 OpenStack 次新版 Rocky 在 CentOS 上的最小化多节点部署过程。&lt;/p&gt;
&lt;p&gt;部署完成后经优化，即可用于生产。&lt;/p&gt;
&lt;p&gt;在 CentOS 上部署 OpenStack，可选途径有多种，你会看到不同的做法，但不经过测试，你并不知道哪一种可以成功。&lt;/p&gt;
&lt;p&gt;次新版 Rocky 已历时考验，软硬件环境，所有的程序、数据库、配置、都是确定的。&lt;/p&gt;
&lt;p&gt;提示：部署过程细节非常多，分清节点的同时，还有很多初看类似之处，但细节不同，需谨慎细心。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3&gt;&lt;span class="strike"&gt;知识准备&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（以下删除 1000 字）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3&gt;&lt;span class="strike"&gt;硬件准备&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（以下删除 2000 字）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3&gt;&lt;span class="strike"&gt;环境部署&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（以下删除 3000 字）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h3&gt;&lt;span class="strike"&gt;软件部署&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（以下删除 6000 字）&lt;/p&gt;
&lt;p&gt;如果你认真的，正在部署 OpenStack，请看完下段内容离开这里：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;DevStack：官方文档，经过了20多个版本，已经相当完善，必读。&lt;/li&gt;
&lt;li&gt;RDOProject Packstack：相对最容易，耗时最少，用于验证为目的。&lt;/li&gt;
&lt;li&gt;RDOProject TripleO Quickstart：复杂，文档也不够好，没有人可以一次成功。&lt;/li&gt;
&lt;li&gt;kolla-ansible：容器部署简化了部署，但减低了可调试性，如果你想定制一下，你将面对一个复杂性陷阱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="openstack-1"&gt;
&lt;h2&gt;痛点：OpenStack 为啥安装不好&lt;/h2&gt;
&lt;p&gt;为什么你遵循的 OpenStack 指南，无法真正让你安装好 OpenStack，因为它们：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;没教你准备硬件&lt;/li&gt;
&lt;li&gt;缺少软硬件环境说明&lt;/li&gt;
&lt;li&gt;未标注软件前置依赖&lt;/li&gt;
&lt;li&gt;未指明软件版本&lt;/li&gt;
&lt;li&gt;运行命令没指明运行目录&lt;/li&gt;
&lt;li&gt;运行命令未记录必要的回显&lt;/li&gt;
&lt;li&gt;没有指明命令运行的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="strike"&gt;本文这些都做了，所以会有些长。但我进行分节和编号，你随时可以知道你进行到了哪里。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h2&gt;呕心沥血的权威《安装指南》，为什么失效 &amp;#64; 2024年2月28日？&lt;/h2&gt;
&lt;p&gt;Because of 刻舟求剑。&lt;/p&gt;
&lt;p&gt;软件有生命周期，软件文档是一种正在生长的生命。&lt;/p&gt;
&lt;p&gt;OpenStack 版本按 26 个字母进化（如今已不够用，换成了年份）。&lt;/p&gt;
&lt;p&gt;书籍写作者部署时，按其中的某个版本教授。&lt;/p&gt;
&lt;p&gt;书付梓时，软件已然又 build 了 1000 次，bug fix 500 次。&lt;/p&gt;
&lt;p&gt;作者在卖的书上写着：“后生，你的疑问请书上见。”你以为部署成功就在书看完后。&lt;/p&gt;
&lt;p&gt;实际上你会发现你继续在失败，还得网上最新文档见。&lt;/p&gt;
&lt;p&gt;这就是技术写作和出版的痛点。通用的，不好写；时效有限的，不好卖。&lt;/p&gt;
&lt;p&gt;步骤流程没有想象的重要，重要的是避坑指南和经验。&lt;/p&gt;
&lt;p&gt;这就是 OpenStack 的多种部署看起来都那么不聪明的样子，像极了盲人摸象。&lt;/p&gt;
&lt;p&gt;验证式部署、单节点部署、大规模部署、容器式部署？&lt;/p&gt;
&lt;p&gt;都是鸡肋。不是想的太简单，就是做的太复杂。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h2&gt;万物部署指南&lt;/h2&gt;
&lt;p&gt;看到此的，我想说的是，也许真有《万物部署指南》一样的法宝：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;法宝一：一手文档。永远优先使用官方文档，如果官方文档出错，则推进官方改正，若不能改，请改换软件。&lt;/li&gt;
&lt;li&gt;法宝二：自知之明。跟随官方文档不奏效的原因，80% 概率是由于，思维和知识中至少其一不到位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没啥能多说的，唯有多踩坑，到后面会悟了，笨方法就是大智慧。&lt;/p&gt;
&lt;img alt="谢谢心累的你，您请随意~" src="https://kaffa.im/static/img/reward.png" /&gt;
&lt;p&gt;末了，如果你觉得本文还算有点用，请 &lt;span class="strike"&gt;别&lt;/span&gt; 扫我的赞赏码&lt;/p&gt;
&lt;/div&gt;
</content><category term="programming"></category><category term="Installation and Deployment Guide"></category><category term="OpenStack"></category></entry></feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Kaffa - 随笔</title><link href="https://kaffa.im/" rel="alternate"></link><link href="https://kaffa.im/feeds/sui-bi.atom.xml" rel="self"></link><id>https://kaffa.im/</id><updated>2019-08-12T12:00:00+08:00</updated><entry><title>P++ 的想法：常见问题（ 全文翻译 ）</title><link href="https://kaffa.im/pplusplus-faq.html" rel="alternate"></link><published>2019-08-12T12:00:00+08:00</published><updated>2019-08-12T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-08-12:/pplusplus-faq.html</id><summary type="html">&lt;p class="first last"&gt;本文《P++ 的想法: 常见问题》是 &lt;a class="reference external" href="https://wiki.php.net/pplusplus/faq"&gt;https://wiki.php.net/pplusplus/faq&lt;/a&gt; 的全文翻译。这是一份对在 internals&amp;#64; 上提出的想法的常见问题澄清，它试图解决许多在随后讨论中被反复提出的问题。1997 年，以色列程序员 Zeev Suraski 及 Andi Gutmans 加入了 Zend 公司 的 PHP 语言开发，发布了 PHP 3, PHP 4, PHP 5，注意没有 PHP 6，再到现在的 PHP 7。 1975 年出生的 Zeev Suraski 在 Zend 工作了 20 年。也许是在语言、架构和库的工作上找不到发展方向了。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;P++ 的想法: 常见问题&lt;/h2&gt;
&lt;p&gt;原文： &lt;a class="reference external" href="https://wiki.php.net/pplusplus/faq"&gt;https://wiki.php.net/pplusplus/faq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;时间: 2019 年 8 月 9 日&lt;/p&gt;
&lt;p&gt;作者: Zeev Suraski, &lt;a class="reference external" href="mailto:zeev&amp;#64;php.net"&gt;zeev&amp;#64;php.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一份对在 internals&amp;#64;译注1 上提出的想法的常见问题澄清，它试图解决许多在随后讨论中被反复提出的问题。&lt;/p&gt;
&lt;p&gt;注：P++ 是一个临时代码命名，未来可能会变化。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;这到底是怎么回事？&lt;/h2&gt;
&lt;p&gt;试图将冗长的邮件内容浓缩为几点：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;PHP 世界有两个大的阵营。第一个大致喜欢 PHP 的动态性，带有强烈的 BC译注2 偏见，并特别强调简单性，另一个更喜欢减掉包袱，拥有更高级、更复杂功能的更严格的语言。&lt;/li&gt;
&lt;li&gt;这里没有“对”或“错”。这两种流派都有效，并具有非常坚定的追随者。然而，创建一种同时迎合这两个阵营的语言则是一项挑战，这也是 internals&amp;#64; 上争论的一贯的原因。&lt;/li&gt;
&lt;li&gt;该提议是创建一种新的 PHP 方言（代码名 P++），与 PHP 并存，但不受语言背后的历史哲学约束。换句话说，这种新方言本质上可能更加严格，它可能会更加大胆地消除向后兼容，并删除被认为是“包袱”的元素（例如短标签），并添加更复杂的特性，尤其是那些非常适合严格类型化的语言的，而无需为 PHP 方言引入相同的复杂性。&lt;/li&gt;
&lt;li&gt;这不是 PHP 代码分支。代码库将是同一个，在该代码库上工作的开发人员是相同的。绝大多数代码都是相同的。只有两种方言之间的特定差异点才会有不同的实现。它有点类似于 PHP 7 中的 strict_types 所做的，只是在更大的范围内。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;我们真的要做的就是因为有些人不能放弃短标签吗？&lt;/h2&gt;
&lt;p&gt;这与短标签无关，“弃用短标签 RFC译注3 ”不是这个想法的主要动力。这个提案的目标是更有野心，它是为 PHP 提供一个清晰的愿景，并希望通过向两个阵营提供他们想要的东西来最终解决两方的紧张关系。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php"&gt;
&lt;h2&gt;为什么要分叉 PHP？&lt;/h2&gt;
&lt;p&gt;这不是分叉。 代码库将完全相同，它将由相同的人开发版本。二进制文件将完全相同，如果你安装 PHP，你也将安装 P++，反之亦然。相同的二进制将运行 PHP，P++ 或组合 PHP/P++ 的应用程序。&lt;/p&gt;
&lt;p&gt;虽然目前还不清楚如何将一个文件“标记”为 P++ 文件，但它可能是文件顶部的某种特殊标记，例如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;?p++?&amp;gt;
&amp;lt;?php 'Hello, world!'; ?&amp;gt;
&lt;/pre&gt;
&lt;p&gt;此外，我们可能会找到将整个命名空间标记为 P++ 的方法，因此，框架不必将每个单独的文件明确标记为 P++。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="internals-low"&gt;
&lt;h2&gt;这意味着我们的开发工作量增加了一倍，而 internals&amp;#64; 的贡献者已经很低（low）了。 我们如何处理？&lt;/h2&gt;
&lt;p&gt;值得庆幸的是，这并不意味着是那样（工作量增加了一倍）。绝大多数代码将在 PHP 模式和 P++ 模式之间共享——包括源代码和运行时。&lt;/p&gt;
&lt;p&gt;无论运行的文件是 PHP 还是 P++文件，数据结构、关键子系统、扩展、Web服务器接口、OPcache 以及其他所有代码都将是完全相同的代码。唯一的额外开发开销会是 PHP 和 P++ 之间的差异部分。&lt;/p&gt;
&lt;p&gt;确实，这意味着我们必须维护某些代码片段的两个版本，并且我们在各个地方都会有一些 if() 语句，因为与 PHP 相比，P++ 可能会有额外的检查。 但是，如果我们要转向更严格的 PHP 版本，这些元素无论如何都必须引入。此外，即使是严格阵营中的人，也不建议我们在没有提供迁移途径的情况下转向未来严格版本——实际上，这种方法所涉及的努力和几乎任何其他的方法都是相似的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php-8-9-php-7-4"&gt;
&lt;h2&gt;当我们转向更严格的 PHP 8/9时， 为什么不只是开发一个永久维护的 PHP 7.4 长期维护版？&lt;/h2&gt;
&lt;p&gt;这种方法存在许多问题。 即使我们忽视这样一个事实，即这会让庞大的动态偏好阵营悬而未决——没有任何特性或性能更新，从开发工作的角度来看，这是不切实际的。 这与这个提议不同，事实上，这确实意味着事实上的分叉。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php-p"&gt;
&lt;h2&gt;我需要在 PHP 和 P++ 之间做出选择吗？&lt;/h2&gt;
&lt;p&gt;是，也不是。 如上所述，当你安装一个，你就有了另一个，所以就应用而言，你可以在一台服务器上运行这两种方言。 然而，实际上，项目和个人通常可能选择并标准化其中一个，类似于严格类型的情况。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;我能在同一个应用程序中混合使用 PHP 和 P++ 吗？&lt;/h2&gt;
&lt;p&gt;是的。 虽然我们需要确定精确的机制，但代码是 PHP 还是 P++ 的指定将在文件级别，而不是在请求级别。 单个执行（请求）可以加载许多不同的文件，这些文件可以来自两种方言。PHP文件中的代码将表现为 PHP 语义——而来自 P++ 文件的代码将表现为 P++ 语义。 这也是，与 strict_types 类似。&lt;/p&gt;
&lt;p&gt;虽然这开始听起来可能听很尴尬，但可能会有非常实用的用例。例如，PHP 应用程序使用的只含 P++ 的框架，反之亦然。 对于那些熟悉 C 和 C++ 的人来说，这有点类似。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;这是否意味着 PHP 将不再发展？ 所有新功能都会用于 P++ 吗？&lt;/h2&gt;
&lt;p&gt;不，这只是意味着它会以不同的方式发展。 严格性和类型相关的功能可能只适用于 P++，并且只能在 P++ 文件中使用。向后兼容偏差将保留在 PHP 中（这并不意味着向后兼容永不会被打破，只是每个这样的案例必须有良好的投资回报案例）。&lt;/p&gt;
&lt;p&gt;但是，与此无关的功能，例如引擎的性能改进（如 JIT ），扩展的开发，或新的异步相关的功能，PHP 和 P++ 都可以使用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;这个方法有什么好处？&lt;/h2&gt;
&lt;p&gt;这种方法有很多好处。 首先，它为 internals&amp;#64; 的两个阵营提供了一个很好的解决方案。 那些喜欢 PHP 动态特性的人可以保留它，而那些喜欢更严格类型语言的人也可以获得它，而不受任何 PHP 限制。 而替代方案是零和游戏，一个阵营的胜利是另一个的失败，反之亦然。&lt;/p&gt;
&lt;p&gt;除了设计一个好的技术解决方案（使我们能够以最少的努力支持整个受众）之外，还可以终结近年来 internals&amp;#64; 上争论的关键根源。&lt;/p&gt;
&lt;p&gt;最后，虽然本文档的大多数读者可能是技术人员，但应该注意的是，启动 P++ 将从一个新的基点译注4不计过去重新开始，可能具有巨大的定位和品牌优势。未使用 PHP 的公司、开发经理和个人开发者更有可能注意到 P++ 的推出，而不是 PHP 8.0 或 PHP 9.0 的推出。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2&gt;我们不是冒着分裂用户群的风险吗？&lt;/h2&gt;
&lt;p&gt;在某种程度上，我们是。但这不是这一想法的缺陷， 而是现实已经存在的表现。&lt;/p&gt;
&lt;p&gt;如上所述，那里有很多人喜欢 PHP 的动态本质，并且谨慎地看待尝试使其越来越多地面向类型。&lt;/p&gt;
&lt;p&gt;与此同时，还有另外一群看着 PHP 的人，自己在想：“为什么它变得如此缓慢，以至于我最终要放弃这动态的废材（原文：dynamic nonsense）？”&lt;/p&gt;
&lt;p&gt;这里没有对或错。这两种观点都有效。当我们研究在这两个相互矛盾的观点之间架起桥梁的可能的解决方案时，没有太多可用的方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;坚持使用动态PHP。这将不会被更严格语言的支持者所接受。&lt;/li&gt;
&lt;li&gt;向严格的PHP发展。动态语言的支持者不会接受这一点。&lt;/li&gt;
&lt;li&gt;分叉代码库。无论如何完成，都是所有参与者的净损失选项。 这样做没有技术优势，即使我们想要（我们不想要），我们也没有足够的贡献者去做。&lt;/li&gt;
&lt;li&gt;提出一些创意解决方案，以满足双方观众的需求。 这就是该提案试图做的。它在保持项目本身统一的同时，也确保两种方言之间的永久互操作性。这虽然会有一定程度的碎片化，但它仍然是满足每个人的主要需求的最小可能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="nikita5"&gt;
&lt;h2&gt;这与 Nikita译注5 版本的想法有何不同？&lt;/h2&gt;
&lt;p&gt;这两个想法之间有许多相似之处，但也存在一些实质性差异。 请注意，这是基于对版本方法的有限理解，因此部分可能缺乏，不准确或不正确。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;在这个提议中，有一个明确的目标是保持当前动态类型的 PHP，作为一个长期的，完全支持的，平等的对等方言。 发版本的方法将当前行为视为“遗留”。 这意味着它可能会被劝止（使用），然后在某些时候弃用和删除。&lt;/li&gt;
&lt;li&gt;推出策略完全不同。 P++ 提案旨在首先关注兼容性破坏元素，例如严格的操作、类型转换逻辑的更改、数组索引处理、需要变量声明等等，并且旨在在 P++ 的第一期提供它们。这样做的目的是允许新项目/框架重新开始，而不需知道在引入更多兼容性更改时，他们可能不得不在一两年内进行重大改写。 版本化提案似乎没有这样的目标，而是旨在逐步添加/更改 PHP 中的元素。&lt;/li&gt;
&lt;li&gt;与推出方式相关，版本化方法不允许只有两种方言，而是任何数量的方言。我们可能有 PHP2020 方言，以及 PHP2022 方言和 PHP2027 方言。 如果我们全部保留它们，实际上这可能会增加我们的维护复杂性。&lt;/li&gt;
&lt;li&gt;该提议还提到了 PHP 与 P++（保守与积极）的不同打破向后兼容策略，而版本化方案可能根本不会涉及该主题。&lt;/li&gt;
&lt;li&gt;版本提案与此提案的定位/营销方面并不完全相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重要的是，要注意这两个想法不一定是相互排斥的。 我们可以介绍 P++ 并使用版本进行改进，特别是当证明很难将所有重要的变化都放到 P++ 的第一期中。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;有哪些挑战？&lt;/h2&gt;
&lt;p&gt;在我们能运行第一个 P++ 应用程序之前，不乏挑战。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;我们需要获得支持。这意味着，两派的人都需要放弃让 PHP 完全动态或完全类型化的梦想，而忽略那些与他们想法不同的人。这似乎是一个非常重大的挑战。&lt;/li&gt;
&lt;li&gt;为获得成功，P++ 第一个版本应该处理来自 PHP 的所有，或至少大多数兼容性破坏的更改，以便切换（可能相当痛苦）的开发人员不必在未来重新审核/彻底重构他们的代码。一些人表示担心，由于我们的开发人员能力有限，他们可能过于乐观，无法在一期发布。一旦我们对列表的内容有了更好的了解，我们就必须对此进行评估。 请注意，这并不意味着我们需要在第一个期中实现我们可能对 P++ 提出的所有想法，只是我们应该优先考虑会触发大量最终用户代码重写的元素，并尝试在我们的第一版之前处理它们。&lt;/li&gt;
&lt;li&gt;当然,最具挑战性的——我们需要为这种新方言找到一个合理的名字。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pplusplus/faq.txt · 最后修改： zeev 于 2019/08/09 21:44&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2&gt;译注&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;internals&amp;#64;：PHP 内部开发人员邮件列表。这里涉及 PHP 的开发机制，当内部讨论成熟后，会公开在 externals，通常用来提交 RFC 和发布版本通知。&lt;/li&gt;
&lt;li&gt;BC：即 Backward Compatibility，向后兼容，也叫向下兼容，兼容过去的版本，即升级的软件要考虑旧版本的兼容性，比如，Office 2019 的 Word 默认使用 .docx 文件格式，但也可以打开 Office 2017/2013/2010，甚至是 2003 的 .doc 格式。相对的概念叫做 FC，即 Forward Compatibility，向前兼容，也叫向上兼容，即升级的软件会考虑对未来的兼容性。这在软件中通常为一个确定的接口和约定，未来依然遵循，即可实现向前兼容。&lt;/li&gt;
&lt;li&gt;RFC：即 Request for Comments，语言特性的加入，以及标准化变更管理的方法，通常加入新特性时，会为新特性提交 RFC 并给出例子，变更委员会评估通过后，语言会合入实现的源码，并入新版本。&lt;/li&gt;
&lt;li&gt;新的基点：a clean slate，美国习语，即不计过去新的开始。&lt;/li&gt;
&lt;li&gt;Nikita：一位 internals&amp;#64; 上的发言者，提议在版本中加入特性。顺便提一句，美剧《Nikita》值得一看。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（本文翻译为笔者原创 ，限于水平有限，如翻译中有不妥的地方请回复留言，如转载请注明出处：IT桃花岛）&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://kaffa.im/php-zeev-resigned-originally-he-wanted-to-start-pplusplus.html"&gt;PHP 联席架构师辞职，原来他想做 P++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="PPlusPlus"></category><category term="FAQ"></category><category term="Zeev Suraski"></category><category term="internals@"></category></entry><entry><title>PHP 联席架构师辞职，原来他想做 P++…</title><link href="https://kaffa.im/php-zeev-resigned-originally-he-wanted-to-start-pplusplus.html" rel="alternate"></link><published>2019-08-11T12:00:00+08:00</published><updated>2019-08-11T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-08-11:/php-zeev-resigned-originally-he-wanted-to-start-pplusplus.html</id><summary type="html">&lt;p class="first last"&gt;PHP 语言的创始人 Rasmus Lerdorf 生于 1968 年，今年已 51 岁，他在 1995 年以 Personal Home Page Tools 为名发布了 PHP 1.0。他的辉煌随着雅虎在搜索领域的颓败而黯淡。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;1997 年，以色列程序员 Zeev Suraski 及 Andi Gutmans 加入了 Zend 公司 的 PHP 语言开发，发布了 PHP 3, PHP 4, PHP 5，注意没有 PHP 6，再到现在的 PHP 7。 1975 年出生的 Zeev Suraski 在 Zend 工作了 20 年。也许是在语言、架构和库的工作上找不到发展方向了。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;题记&lt;/h2&gt;
&lt;p&gt;PHP 语言的创始人 Rasmus Lerdorf 生于 1968 年，今年已 51 岁，他在 1995 年以 Personal Home Page Tools 为名发布了 PHP 1.0。他的辉煌随着雅虎在搜索领域的颓败而黯淡。&lt;/p&gt;
&lt;p&gt;1997 年，以色列程序员 Zeev Suraski 及 Andi Gutmans 加入了 Zend 公司 的 PHP 语言开发，发布了 PHP 3, PHP 4, PHP 5，注意没有 PHP 6，再到现在的 PHP 7。 1975 年出生的 Zeev Suraski 在 Zend 工作了 20 年。也许是在语言、架构和库的工作上找不到发展方向了。&lt;/p&gt;
&lt;p&gt;前几天 Zeev Suraski 宣布从 Zend 离职，业界比较惊讶，PHP 7 优化的开发者鸟哥说是这是早已预定好的事。原来 Zeev Suraski 辞职，他想做 P++，那 P++ 是啥？他通过《&lt;a class="reference external" href="https://wiki.php.net/pplusplus/faq"&gt;P++ idea: FAQ&lt;/a&gt;》进行了回答，笔者作了全文翻译。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php"&gt;
&lt;h2&gt;关于 PHP 语言动态静态的看法&lt;/h2&gt;
&lt;p&gt;笔者自 PHP 4.0 时开始使用，觉得 PHP 语言的动态性与 Web 应用细节经常发生变化的需求是绝配。在 PHP 最初的时代，语言哲学就是——不需要框架，因为 PHP 说——我就是框架。&lt;/p&gt;
&lt;p&gt;因此，某种程度上，我不太理解那些在 Web 应用开上把 PHP 和 Python 写成 Java 风味的程序员，数不清的类和依赖，冗长的命名空间、包名，类的深层次调用随处可见，各种不必要的自定义异常，繁重的框架。&lt;/p&gt;
&lt;p&gt;看着这样的代码，你会有一种想用水果刀把代码赘肉割掉的冲动，这样代码可以减少一半，运行速度和消耗也可大幅降低，可维护性提高。&lt;/p&gt;
&lt;p&gt;PHP 也让我想到 Python 最早的一批 Web 框架 Quixote，用中文形容就是“佛性 ” ，发布过三个版本，现在还用 1.x 的大有人在，因为在那个年代 Web 应用的痛点已经被框架妥善地解决，这点上，PHP 本身就完成的很好。Quixote 并不优雅，但能用。&lt;/p&gt;
&lt;p&gt;PHP 在新时代，受到 Go 和 Rust 的冲击，也借鉴了同类语言语法，加入了丰富的语言特性，逐步进化为一门花招较多、看起来更完善的动态语言。不可否认，它确实是在不断进化，于是也产生了 Laravel 这样搞定一切的框架，却不一定比 Django、Flask、ROR、Node.js 的方案更容易获得市场认可，因为 PHP 的动态性是优势，如果要静态类型检查，你 Rust 啊。&lt;/p&gt;
&lt;p&gt;在国内软件工程现状上，看似优雅的设计最后会成为绊脚石，优雅的框架只适合观赏，或给能理解优雅的程序员使用，而这类人在企业中往往凤毛麟角。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;静态检查的剖析&lt;/h2&gt;
&lt;p&gt;Talk is cheap，show me your code. 以下即为 PHP 7 中开启静态检查的方式，P++ 的提案，就是可以全局开启，并在更大范围内开启:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;?php declare(strict_types=1);

function sum(float $a, float $b) {
    return $a + $b;
}
echo sum(1, 1);
echo sum(1, '1');
&lt;/pre&gt;
&lt;p&gt;以上代码，如果第一行 strict_types=0 时，可以正常输出 22，而上述代码的执行会报错:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
2
( ! ) Fatal error: Uncaught TypeError: Argument 2 passed to sum() must be of the type float, string given, called in
test_strict_type.php on line 7 and defined in
test_strict_type.php on line 3
( ! ) TypeError: Argument 2 passed to sum() must be of the type float, string given, called in test_strict_type.php on line 7 in test_strict_type.php on line 3
Call Stack
#   Time    Memory  Function        Location
1   0.0005  409184  {main}( )       ...\test_strict_type.php:0
2   0.0006  409184  sum( )  ...\test_strict_type.php:7
&lt;/pre&gt;
&lt;p&gt;结论还是，语言特性对于了解语言特性的人有用。&lt;/p&gt;
&lt;p&gt;实践上，笔者对 P++ 提案持不完全支持态度，以有限的社区专注动态特性，可以做的还有更多。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="PHP"></category><category term="P++"></category><category term="Zeev Suraski"></category><category term="Rasmus Lerdorf"></category><category term="PPlusPlus FAQ"></category></entry><entry><title>Microsoft Designer Mouse 拆解</title><link href="https://kaffa.im/disassemble-the-microsoft-designer-mouse.html" rel="alternate"></link><published>2019-08-07T12:00:00+08:00</published><updated>2019-08-07T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-08-07:/disassemble-the-microsoft-designer-mouse.html</id><summary type="html">&lt;p class="first last"&gt;本文简单讲解如何拆解 Microsoft Designer Mouse&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;拆解关键&lt;/h2&gt;
&lt;p&gt;所需工具&lt;/p&gt;
&lt;img alt="所需工具" src="https://kaffa.im/img/2019/tool-for-disassembly.png" /&gt;
&lt;p&gt;拆开的样子&lt;/p&gt;
&lt;img alt="拆开的样子" src="https://kaffa.im/img/2019/microsoft-designer-mouse.png" /&gt;
&lt;p&gt;拆开的关键之处：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;外壳有四处卡，上面两个卡是向后扣的，容易拨开，后面两个卡外壳是向内卡在两个圆柱上，这里需要一根类似回形针的东西从下方伸进去，再向外侧拨开弹片，不注意的话，容易损坏。&lt;/li&gt;
&lt;li&gt;需要一把对上型号的六角起子，这个尺寸是通用的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;价格&lt;/h2&gt;
&lt;p&gt;只能说，当年购入微软这只鼠标 199 元的价格，确实是 Designer Mouse，卖的是设计。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Microsoft Designer Mouse"></category></entry><entry><title>Linux 版本</title><link href="https://kaffa.im/linxu-distributions.html" rel="alternate"></link><published>2019-08-05T12:00:00+08:00</published><updated>2019-08-05T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-08-05:/linxu-distributions.html</id><summary type="html">&lt;p class="first last"&gt;本文简单聊聊 Linux 发行版&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;Linux 是开源、免费的操作系统，是 Freeware 和 Open Source 运动的代表作。它代表着低成本的商业方案，被无数公司依赖。CentOS 是常用的一种 Linux 发行版，被大量公司和个人使用。它是 Red Hat Enterprise Linux 的开源编译版，因稳定而闻名。稳定是不尝鲜的另一种说法，其中默认的软件仓库选择虽然不是各种软件最新版，却是久经考验被无数程序员采坑过的稳定版。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;Linux 内核&lt;/h2&gt;
&lt;p&gt;Linux 的内核即 Linux Kernel，由 Linux 基金会负责发行，它并不是完整的操作系统，而是只包含设备驱动、文件管理、资源管理等功能的操作系统核心，是整个 Linux 开源生态的上游。Linux 核心加 GNU 工具链和库、文档和软件，以及窗口系统，才构成完整的操作系统。&lt;/p&gt;
&lt;p&gt;Linux 核心`官方网站`_上最新版是 &lt;a class="reference external" href="https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.2.6.tar.xz"&gt;5.2.6&lt;/a&gt;，其中第一个数字 5 是主版本，第二个数字 2 是偶数表示稳定版，如果第二个数字是奇数则表示是开发版，第三个 6 数字表示修订次数。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;Linux 发行版&lt;/h2&gt;
&lt;p&gt;Linux 发行版有太多种，根据其集成的软件分派系稍作列举：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Red Hat Enterprise Linux：RPM 系，最好的商业版本，简称 RHEL&lt;/li&gt;
&lt;li&gt;Fedora： RPM 系 商业版本，包含最新软件库，Ret Hat 的新软试验田？&lt;/li&gt;
&lt;li&gt;CentOS：RPM 系社区版本，不包含 RHEL 闭源高级功能的开源良心之作，服务器明智之选。&lt;/li&gt;
&lt;li&gt;openSuse：RPM 系，源自 Slackware 的一种德国发行版，目前由 Novell 公司维护，严谨安全精致，缺点是臃肿，考验硬件。&lt;/li&gt;
&lt;li&gt;Debian：Dpkg 系根基，最纯正的 GNU/Linux，只包含 GPL 协议软件，基于它的发行版多，虽然是社区维护，但都是骨灰级高手，直接用的人相对少。&lt;/li&gt;
&lt;li&gt;Ubuntu：基于 Debian 的商业代表，为桌面系统做出了巨大贡献，提供最友好易用的桌面系统软件。近年 Ubuntu Server 份额有提升，农村包围城市？&lt;/li&gt;
&lt;li&gt;Slackware：Unix 系，目录严谨，Linux 发行版元老，现在较少人用&lt;/li&gt;
&lt;li&gt;Elementary OS：桌面系， 基于 Ubuntu 的 macOS 界面， 视觉动物首选。&lt;/li&gt;
&lt;li&gt;Linux Mint： 桌面视觉系，基于 Ubuntu，胜于 Ubuntu Desktop&lt;/li&gt;
&lt;li&gt;Arch Linux：Geek 系，包管理之王，可实现不重启滚动更新，老机器可选&lt;/li&gt;
&lt;li&gt;Linux From Scratch： Geek 系，定制王者， 如果你想最大化定制操作系统可以选它&lt;/li&gt;
&lt;li&gt;Gentoo：Geek系，Unix 系，定制昔日王者，所有安装包靠从源代码编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他还有类 Unix 发行版，比如 FreeBSD、NetBSD、OpenBSD，内核不同，但包含软件类似，传说 BSD 系统可稳定运行 10 年不关机。&lt;/p&gt;
&lt;p&gt;值得一提是，这些发行版除了 BSD 以外，其余使用相同的内核，不同发行版只是软件库、桌面环境、流行度的差异。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;如何选择发行版&lt;/h2&gt;
&lt;p&gt;人生苦短，如果 Linux 不是你人生不可获取的部分，请：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器选 CentOS，&lt;/p&gt;
&lt;p&gt;桌面系统选 Ubuntu，&lt;/p&gt;
&lt;p&gt;其余请随意，毕竟 Linux 的情怀就是 Free。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Linux Distributions"></category><category term="Arch Linux"></category><category term="CentOS"></category><category term="Debian"></category><category term="Elementary OS"></category><category term="Fedora"></category><category term="FreeBSD"></category><category term="Gentoo"></category><category term="Linux From Scratch"></category><category term="Linux Mint"></category><category term="NetBSD"></category><category term="openSuse"></category><category term="Red Hat Enterprise Linux"></category><category term="Slackware"></category><category term="Ubuntu"></category></entry><entry><title>reStructureText 九个实用语法</title><link href="https://kaffa.im/nine-rules-on-restructuredtext-practical-grammar.html" rel="alternate"></link><published>2019-07-25T12:00:00+08:00</published><updated>2019-07-25T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-07-25:/nine-rules-on-restructuredtext-practical-grammar.html</id><summary type="html">&lt;p class="first last"&gt;本文是 reStructureText 实用语法指南，其中列出最常用的九个语法，用来写博客足矣。其余更多细节，请查阅官方指南。&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;槽&lt;/h2&gt;
&lt;p&gt;Markdown 各方实现经常不一致，累觉无爱，相比来说 reStructureText 更严谨丰富，换句话说就是更复杂。但作为 Pelican 引擎的主动力，我对语言技巧的基本态度是用最熟悉基础的即可写出文章，综合比较，我放弃了 md 转回了 rst。&lt;/p&gt;
&lt;p&gt;本文说的实用主义，即达到能写文章即可的程度。不看 rst 所有的语法是什么能做什么，而是看写文章用到 rst 哪些语法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;语法指南&lt;/h2&gt;
&lt;p&gt;本文是 reStructureText 实用语法指南，其中列出最常用的九个语法，用来写博客足矣。其余更多细节，请查阅官方指南。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、文本样式&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
*斜体*  **粗体**  ``段内标记``
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;  &lt;strong&gt;粗体&lt;/strong&gt;  &lt;tt class="docutils literal"&gt;段内标记&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、标题&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
================================
reStructureText 实用语法指南
================================

第 1 章 标题
===============

第 1.1 节 标题
-----------------

第 1.1.1 小节 标题
~~~~~~~~~~~~~~~~~~~~~~

第 1.2 节 标题
-----------------

第 2 章 标题
===============
&lt;/pre&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;reStructureText 实用语法指南&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;第 1 章 标题&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;第 2 章 标题&lt;/h2&gt;
&lt;p&gt;此处完整效果预览请在VSCode中试，如遇到问题，参阅我另一篇 &lt;a class="reference external" href="https://kaffa.im/preview-restructuretext-file-in-vscode.html"&gt;用 VSCode 预览 reStructureText 文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、段落&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
段落是由空行分割的文字。

这是另一个段落。
&lt;/pre&gt;
&lt;p&gt;段落是由空行分割的文字。&lt;/p&gt;
&lt;p&gt;这是另一个段落。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、术语表和列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;术语表&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
术语一
    术语解释，需要缩进。

    甚至可以有多个段落。

术语二
    描述
&lt;/pre&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;术语一&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first"&gt;术语解释，需要缩进。&lt;/p&gt;
&lt;p class="last"&gt;甚至可以有多个段落。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;术语二&lt;/dt&gt;
&lt;dd&gt;描述&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;strong&gt;无序列表&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* 这是一个无序列表
* 它含有两项，第二
  项占两行
&lt;/pre&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;这是一个无序列表&lt;/li&gt;
&lt;li&gt;它含有两项，第二
项占两行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;有序列表&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1. 这是一个有序列表
2. 它也有两项
&lt;/pre&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;这是一个有序列表&lt;/li&gt;
&lt;li&gt;它也有两项&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;多级列表&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* 这是
* 一个列表

    * 含一个缩进列表子项
    * 和另一个子项

* 这里是父项的继续
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;这是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;一个列表&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;含一个缩进列表子项&lt;/li&gt;
&lt;li&gt;和另一个子项&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;这里是父项的继续&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;五、代码&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
五、代码::

    # PEP 20 -- The Zen of Python
    import this
&lt;/pre&gt;
&lt;p&gt;显示为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# PEP 20 -- The Zen of Python
import this
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;六、表格&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
=====  =====  =======
A      B      A and B
=====  =====  =======
False  False  False
True   False  False
False  True   False
True   True   True
=====  =====  =======
&lt;/pre&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="29%" /&gt;
&lt;col width="29%" /&gt;
&lt;col width="41%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;A&lt;/th&gt;
&lt;th class="head"&gt;B&lt;/th&gt;
&lt;th class="head"&gt;A and B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;更复杂的格式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
+------------------------+------------+----------+----------+
| 第一行第一列           | 第二列     | 第三列   | 第四列   |
| 标题行第二列           |            |          |          |
+========================+============+==========+==========+
| 第二行第一列           | 第二列     | 第三列   | 第四列   |
+------------------------+------------+----------+----------+
| 第三行第一列           | ...        | ...      |          |
+------------------------+------------+----------+----------+
&lt;/pre&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="43%" /&gt;
&lt;col width="21%" /&gt;
&lt;col width="18%" /&gt;
&lt;col width="18%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;第一行第一列
标题行第二列&lt;/th&gt;
&lt;th class="head"&gt;第二列&lt;/th&gt;
&lt;th class="head"&gt;第三列&lt;/th&gt;
&lt;th class="head"&gt;第四列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;第二行第一列&lt;/td&gt;
&lt;td&gt;第二列&lt;/td&gt;
&lt;td&gt;第三列&lt;/td&gt;
&lt;td&gt;第四列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;第三行第一列&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;七、注释&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
..
    这个缩进
    是一个注释。

    同级依然是注释
&lt;/pre&gt;
&lt;!-- 这个缩进
是一个注释。

同级依然是注释 --&gt;
&lt;p&gt;上方 rst 源文件中含有一段注释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、超链接&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
`链接 &amp;lt;https://kaffa.im/&amp;gt;`_

这段含有一个`链接`_。

.. _`链接`: https://kaffa.im/
&lt;/pre&gt;
&lt;p&gt;&lt;a class="reference external" href="https://kaffa.im/"&gt;这是链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这段含有一个 &lt;a class="reference external" href="https://kaffa.im/"&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、图片&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
.. image:: https://kaffa.im/img/reward.png
    :alt: 赞赏码
&lt;/pre&gt;
&lt;p&gt;加上属性:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
.. image:: kaffa.png
    :height: 100
    :width: 200
    :scale: 50
    :alt: 图片的替换文字
&lt;/pre&gt;
&lt;img alt="赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="reStructuredText Grammar"></category></entry><entry><title>如何编写一个 VSCode 扩展并发布到 Visual Studio Marketplace</title><link href="https://kaffa.im/how-to-create-a-vscode-extension-and-publish-it-to-visualstudio-marketplace.html" rel="alternate"></link><published>2019-07-23T12:00:00+08:00</published><updated>2019-07-23T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-07-23:/how-to-create-a-vscode-extension-and-publish-it-to-visualstudio-marketplace.html</id><summary type="html">&lt;p class="first last"&gt;本文假设你熟悉 node.js 和 npm 工具，用过 Git，并懂点 JavaScript，那么本文将一步步教你编写一个 VSCode 扩展，并发布到微软 Visual Studio Marketplace。&lt;/p&gt;
</summary><content type="html">&lt;img alt="编写 VSCode 插件" src="https://kaffa.im/img/2019/create-vscode-extension.png" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;本文假设你熟悉 node.js 和 npm 工具，用过 Git，并懂点 JavaScript，那么本文将一步步教你编写一个 VSCode 扩展，并发布到微软 Visual Studio Marketplace。&lt;/p&gt;
&lt;p&gt;VSCode 已是免费文本编辑器/IDE的王者，但其文本闪改能力还是不如一些老牌文本编辑器，比如 &lt;a class="reference external" href="http://www.everedit.net/"&gt;EverEdit&lt;/a&gt; 与 EmEditor，但它免费呀，所以，用它用它用它。&lt;/p&gt;
&lt;p&gt;在文本中插入文件名是个常用场景，比如编辑本文时，第一行就会用到，笔者在 EverEdit 和 EmEditor 中编写过脚本插件，基本都只需要一个文件和几行脚本代码。&lt;/p&gt;
&lt;p&gt;考虑到 VSCode 有一个全球生态，那么 Visual Studio Marketplace 中是否能找到一个类似的插件呢，答案是：没有。于是，我们做一个呗。&lt;/p&gt;
&lt;img alt="If not me, who? If not now, when?" src="https://kaffa.im/img/2019/if-not-me-who-if-not-now-when.png" /&gt;
&lt;p&gt;在 VSCode 关于中，我们可以看到它的技术栈如下，其插件采用 JavaScript 或 TypeScript 编写。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Electron: 4.2.5&lt;/li&gt;
&lt;li&gt;Chrome: 69.0.3497.128&lt;/li&gt;
&lt;li&gt;Node.js: 10.11.0&lt;/li&gt;
&lt;li&gt;V8: 6.9.427.31-electron.0&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;具体步骤&lt;/h2&gt;
&lt;p&gt;1、假设你已安装 node.js 和 git&lt;/p&gt;
&lt;p&gt;2、如果你没有用过 Yeoman 脚手架工具，那么现在正是时候，装上它:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
npm install -g yo generator-code
&lt;/pre&gt;
&lt;p&gt;3、利用 Yeoman 建立项目框架:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
yo code

# ? What type of extension do you want to create? New Extension (TypeScript)
# ? What's the name of your extension? insert-filename
### Press &amp;lt;Enter&amp;gt; to choose default for all options below ###
# ? What's the identifier of your extension? insert-filename
# ? What's the description of your extension?
# ? Initialize a git repository? Yes
# ? Which package manager to use? npm
&lt;/pre&gt;
&lt;p&gt;扩展项目就创建好了，下一步，让我们运行起来。&lt;/p&gt;
&lt;p&gt;4、执行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
code ./insert-filename
&lt;/pre&gt;
&lt;p&gt;再按 &lt;tt class="docutils literal"&gt;F5&lt;/tt&gt; 运行，这时，VSCode 会启动一个新窗口，这个窗口中 Yeoman 脚手架项目 insert-filename 已经加载了插件。&lt;/p&gt;
&lt;p&gt;5、让我们按下 &lt;tt class="docutils literal"&gt;Ctrl + Shift + P&lt;/tt&gt;，输入 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;insert-filename&lt;/span&gt;&lt;/tt&gt;，可以看到这条命令，回车后应该可以看到一条 Hello World！的信息在 VSCode 的右下角弹出来。&lt;/p&gt;
&lt;p&gt;6、接着，我们便可以开始编写插入文件名的代码了，还可以调试哟！让我们打开 &lt;tt class="docutils literal"&gt;src/extension.ts&lt;/tt&gt; 文件。为便于理解，请参阅中文注释:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import { commands, workspace, window, ExtensionContext } from 'vscode';

// 在所有选区中插入文件名
function replaceEditorSelection() {
    const editor = window.activeTextEditor;
    if (editor === undefined) {
        return;
    }
    const selections = editor.selections;
    editor.edit((editBuilder) =&amp;gt; {
    selections.forEach((selection) =&amp;gt; {
        let url = editor.document.fileName;
        let urlFormatted = url.replace(/\\/g, '/');
        let lastPart = urlFormatted.split('/').pop() || '';
        editBuilder.replace(selection, '');
        editBuilder.insert(selection.active, lastPart);
    });
    );
}

// 插件激活
export function activate(context: ExtensionContext) {
    console.log('Congratulations, your extension &amp;quot;Insert Filename&amp;quot; is now active!');
    // 注册一条命令
    let disposable = commands.registerCommand('extension.insertFilename', () =&amp;gt; replaceEditorSelection());

    context.subscriptions.push(disposable);
}

// 插件待用
export function deactivate() {
    console.log('Your extension &amp;quot;Insert Filename&amp;quot; is now inactive!');
}
&lt;/pre&gt;
&lt;p&gt;7、其次，最重要的是编辑 package.json 文件，最重要的 contributes 配置，以下配置分别在命令、编辑器右键菜单上注册了此命令，并设置其快捷键:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;contributes&amp;quot;: {
    &amp;quot;commands&amp;quot;: [
        {
            &amp;quot;command&amp;quot;: &amp;quot;extension.insertFilename&amp;quot;,
            &amp;quot;title&amp;quot;: &amp;quot;Insert Filename&amp;quot;
        }
    ],
    &amp;quot;menus&amp;quot;: {
        &amp;quot;editor/context&amp;quot;: [
            {
                &amp;quot;command&amp;quot;: &amp;quot;extension.insertFilename&amp;quot;,
                &amp;quot;group&amp;quot;: &amp;quot;extension&amp;#64;1&amp;quot;
            }
        ]
    },
    &amp;quot;keybindings&amp;quot;: [
        {
            &amp;quot;command&amp;quot;: &amp;quot;extension.insertFilename&amp;quot;,
            &amp;quot;key&amp;quot;: &amp;quot;ctrl+alt+i&amp;quot;,
            &amp;quot;mac&amp;quot;: &amp;quot;shift+cmd+i&amp;quot;,
            &amp;quot;when&amp;quot;: &amp;quot;editorTextFocus&amp;quot;
        }
    ]
}
&lt;/pre&gt;
&lt;p&gt;8、更详细的代码和配置文件请移步 GitHub 仓库：&lt;a class="reference external" href="https://github.com/kaffa/vscode-insert-filename"&gt;vscode-insert-filename 插件源码&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;编译发布&lt;/h2&gt;
&lt;p&gt;到目前为止，我们的测试都是直接运行插件，现在让我们对项目进行编译，得到 insert-filename-0.0.2.vsix 文件，就可以进行发布了。&lt;/p&gt;
&lt;p&gt;9、为编译插件，我们需要下载微软 VSCode Extension 工具 vsce:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
npm install -g vsce
&lt;/pre&gt;
&lt;p&gt;10、安装完毕后，让我们执行如下指令进行编译:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vsce package
&lt;/pre&gt;
&lt;p&gt;11、编译成功后，项目目录中会得到 insert-filename-0.0.2.vsix 文件，再运行如下命令发布:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vsce publish
&lt;/pre&gt;
&lt;p&gt;不出意料，你会得到 401 错误，是因为向微软市场发布这个插件，需要一个 &lt;a class="reference external" href="https://aka.ms/SignupAzureDevOps"&gt;Azure DevOps&lt;/a&gt; 账号，你可以用一个 Microsoft 账号登录跳转注册 &lt;a class="reference external" href="https://aka.ms/SignupAzureDevOps"&gt;Azure DevOps&lt;/a&gt; 即可。&lt;/p&gt;
&lt;p&gt;接下来，我们不用创建项目，直接在右上角个人头像菜单 &lt;tt class="docutils literal"&gt;Security&lt;/tt&gt; 中创建一个 Personal Access Tokens，选项如下，先点击 &lt;tt class="docutils literal"&gt;Show all scopes&lt;/tt&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Organization：All accessible organization&lt;/li&gt;
&lt;li&gt;Scopes: Marketplace 中的 Acquire and Manage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再点击 &lt;tt class="docutils literal"&gt;Create&lt;/tt&gt; 按钮，生成成功后，点击 &lt;tt class="docutils literal"&gt;Copy&lt;/tt&gt;，&lt;strong&gt;注意&lt;/strong&gt;：这个Token只会在这个时候出现一次，所以，你得找一个不会忘记的地方记录下来。&lt;/p&gt;
&lt;p&gt;再执行此命令，将其中的 kaffa 换成你的 id，输入刚才创建的 Token:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vsce create-publisher kaffa
&lt;/pre&gt;
&lt;p&gt;12、发布:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
vsce publish
&lt;/pre&gt;
&lt;p&gt;到这里，我们的插件就发布成功了，过几分钟，就可以官网看到你的插件了，并可以在 VSCode 插件中搜索了，记得做一些关键字 SEO，并升级一下版本。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本插件发布在 &lt;a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=kaffa.insert-filename"&gt;Visual Studio Marketplace&lt;/a&gt;，欢迎下载使用。&lt;/p&gt;
&lt;p&gt;祝各位读者读完本文，能顺利安装、编写、编译、发布你的插件，如果在具体步骤中遇到问题，请回复和留言。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="VSCode Extension"></category><category term="vsce"></category><category term="Visual Studio Marketplace"></category></entry><entry><title>macOS 的前世今生及访达中拷贝文件的路径的方法</title><link href="https://kaffa.im/macos-history-and-copy-file-path-in-finder-app.html" rel="alternate"></link><published>2019-06-09T05:04:00+08:00</published><updated>2019-06-09T05:04:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-06-09:/macos-history-and-copy-file-path-in-finder-app.html</id><summary type="html">&lt;p class="first last"&gt;想介绍几种在访达（Finder）中拷贝文件路径的方法，但一小时后不小心按下浏览器回退，再写便就此篇加上了一些 macOS 的历史。&lt;/p&gt;
</summary><content type="html">&lt;img alt="MacOS" src="https://kaffa.im/img/2019/macos.png" /&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;为什么写 macOS 历史&lt;/h2&gt;
&lt;p&gt;题记：想介绍几种在访达（Finder）中拷贝文件路径的方法，但一小时后不小心按下浏览器回退，再写便就此篇加上了一些 macOS 的历史。&lt;/p&gt;
&lt;p&gt;为什么写？因为 macOS 的历史，也是现代操作系统发展史，与大学书本中的内容有距离；另一方面，历史由事件组成，软件发展史中包含了软件功能竞争的关键点。&lt;/p&gt;
&lt;p&gt;操作系统即 Operating System，简称 OS，是一类让人使用机器的人机交互软件。如今的 Windows、Linux、Unix、iOS、Android、Chrome OS，及最近华为公司的鸿蒙，都是操作系统，它们有的用在桌面，有的用在服务器，有的适用上网本，有的是为移动手机而定制。&lt;/p&gt;
&lt;p&gt;macOS 是苹果公司的桌面操作系统，很多果粉更加熟悉的名字其实是 Mac OS X，就在一周前苹果公司 iPad OS 发布了，这样和 iOS、tvOS、watchOS 一起，苹果公司为其产品线 iPhone、iPad、Mac、TV、Watch 分别定制了操作系统。&lt;/p&gt;
&lt;p&gt;虽然苹果 Mac OS 和微软 Windows 一样都是商用闭源操作系统，其历史资料不易查找，但我们还是试图着墨追溯这段有趣而悠久的软件史。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;源起和发展脉络&lt;/h2&gt;
&lt;p&gt;1976 年，我们的水果厂牌诞生，这家 Logo 被图灵咬缺一口公司，字母表排序非常靠前。&lt;/p&gt;
&lt;p&gt;1984 年，苹果 Macintosh 电脑诞生，20 世纪 80 年代其实都是 Macintosh System 6 的天下，随后开发 Macintosh 的苹果雇员以头脑风暴的形式为其路径定了几个代号：Blue、Pink、Red，Blue 即 System 7，Pink 未完全发布，Red 是比 Pink 更 Pink 的高级系统，其命运接着表述。&lt;/p&gt;
&lt;p&gt;其时，Bill Gates 的微软开发了 Windows 和 Win32 API，敌方已经进入了战场。Blue、Pink 对比不断升级的 Windows 95 略显式微。为兼容 x86 架构，Apple 与 Novell 研发了兼容 x86 的 Star Trek，但由于苹果系统架构路线定为 PowerPC 架构，且硬件供应商不太支持，这个系统最终没有发布。&lt;/p&gt;
&lt;p&gt;直到 2005 年以后，Apple 调整为 x86 路线，才借 Darwin/x86 研发了存活至今还大放异彩的灵魂产品 iMac 与 MacBook Pro。&lt;/p&gt;
&lt;p&gt;Red 就是其后的 Raptor，吸纳了 Star Trek 基因，但预算不足，Raptor 也夭折了。&lt;/p&gt;
&lt;p&gt;其实，苹果公司早在 1994 年初就宣布，将用 10 年的软件经验研发 Macintosh 第 8 代，系统命名为 Mac OS 8，代号 Copland，这个系统一部分的使命是为迎战日益增长的 Windows 和 Internet Explorer，但结果我们都已知晓，“这一战我无遗憾”，按下不表。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;首战&lt;/h2&gt;
&lt;p&gt;Copland 是基于 RISC 的 PowerPC 架构，集先进技术于一身，包括 ColorSync、OpenDoc、Power 系，Quick 系软件，还实现了自定义主题，甚至是与 Dos 和 Windows 的互操作、网络协议栈。此项目的干系人们对其预期包括：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;方便硬件驱动开发的硬件抽象层 HSL&lt;/li&gt;
&lt;li&gt;微内核 NuKernel&lt;/li&gt;
&lt;li&gt;IO、网络、文件系统作为服务运行于微内核之上&lt;/li&gt;
&lt;li&gt;抢占式多任务，对标 Windows NT&lt;/li&gt;
&lt;li&gt;内存保护和虚拟内存，对标 Windows NT&lt;/li&gt;
&lt;li&gt;灵活的系统扩展机制&lt;/li&gt;
&lt;li&gt;元数据及文件内容搜索&lt;/li&gt;
&lt;li&gt;热升级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但期望被迫终止于软件工程方法的滞后，各方的软件难以集成，学院派 Unix 内核人才都被微软挖走去做 Windows NT 了，Copland 需求中内存保护未能实现。1996 年，Copland 项目中止。&lt;/p&gt;
&lt;p&gt;1997 年出于商业计划，苹果公司发布了 System 7.6，重命名为 Mac OS 7.6，但缺少犀利的操作系统，无法对敌微软的 Windows 系统，成为苹果的阿喀琉斯之伤。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="beos"&gt;
&lt;h2&gt;BeOS&lt;/h2&gt;
&lt;p&gt;管理层失去了方向，苹果甚至考虑过和微软合作在 Windows 之上开发 Apple OS，还考虑过 Sun Solaris 和 BeOS，这里 BeOS 也出自于人才辈出的苹果前雇员，我为什么要用也？&lt;/p&gt;
&lt;p&gt;虽然 BeOS 的天才们实现了内存保护和抢占式多任务，它擅长多媒体，还实现了BeFS，支持文件元数据，甚至支持 PowerPC 架构，但关键的打印和文件共享功能被遗忘了，软件方法论上叫做未完全分解权重需求且未排优先级。随后 BeOS 被大家耳熟能详的 Palm 公司收购，结束了它短暂的历史。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="next-openstep"&gt;
&lt;h2&gt;NeXT OPENSTEP&lt;/h2&gt;
&lt;p&gt;也可能商务谈判就差那么一分钱，Apple 最终没有完成收购。其中的缘由无从考证，但有一点确定的是，Apple 的管理层发现了另一个选项，Apple 前任帮主 Steve Jobs 的 NeXT 公司的 OPENSTEP，一种已被企业市场认可的操作系统。&lt;/p&gt;
&lt;p&gt;1997 年 2 月 4 日，Apple 用 4 亿多刀收购了 NeXT，帮主重回 Apple，从其被辞算起，已过去了 12 年。值得注意的是，苹果的收获还包括一项技术资产——大家熟悉的 Objective-C 和 NeXT 的“科技x艺术”致胜原力——工业设计师和硬件工厂。&lt;/p&gt;
&lt;p&gt;Objective-C 这种像 C 又像 SmartTalk 的语言不同于 Windows 背后的 C++，Objective-C 更简单。笔者在学习 GUN GCC 下的 Objective-C 时，还玩过一阵 OPENSTEP，它具有一个顶部的 Docker，一个多级菜单和一系列丰富的应用程序，有NFS、还具有 Unix 命令行界面、CD多媒体系统，邮件、辞典、拼写检查、支持网络的文件浏览器，底层的面向对象的驱动程序框架，以及文件内容搜索、经典的拖放等操作，开发程序 Project Builder 和 Interface Builder，Application Kit、Music Kit、Sound Kit 开发包，是不是像是看到了 Xcode 和现代 macOS 的雏形？&lt;/p&gt;
&lt;p&gt;很多人都说 macOS 是 BSD 内核，没错！因为 NEXTSTEP 0.8 基于 Mach 2.0 和 BSD 4.3，而现代 Mac OX 是原 Macintosh 技术遗产迁移到 NEXTSTEP 实现的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mach"&gt;
&lt;h2&gt;微内核 Mach&lt;/h2&gt;
&lt;p&gt;NEXTSTEP 的商业卖点微内核其实在当时并未完善，但其中 Mach 微内核无疑是关键。微内核 Mach 并不涉及操作系统的文件系统、网络和 IO，是硬件和固件之上最基础的操作系统核心。&lt;/p&gt;
&lt;p&gt;Mach 的故事开始于 1975 年，比苹果厂牌早一年出现，第一版叫做 RIG，因为缺少内存分页等明显缺点，RIG 失败了，1981 年 4 月，RIG 主要开发者 Richard Rashid 开发了 Accent 解决了 RIG 的缺点，他后加入了 Microsoft Research。熟悉历史的人会把 RIG 叫做 Mach 0.8，Accent 叫做 Mach 0.9。&lt;/p&gt;
&lt;p&gt;1984 年，Mach 的主要开发目标是微内核和兼容 Unix，于是 Mach 使用了 BSD 4.3 作为起点。几个基本概念被提出：任务（Task）、线程（Thread）、端口（Port）、消息（Message），以及内存对象（Memory Object）用以实现物理到虚拟内存的分页映射，后续 FreeBSD 的内存体系结构即基于此。&lt;/p&gt;
&lt;p&gt;最终，微内核真正意义上的实现是在 1996 年 7 月，也就是 OPENSTEP 4.0，这也是两年后 OPENSTEP 4.2 被苹果收购的原因之一。而 Mach 主要开发者 Avie 成为了苹果的首席软件技术官。&lt;/p&gt;
&lt;p&gt;另一个需要解释的是基于 Linux 1.3 的 MkLinux 内核，MkLinux 内核作为单个 Mach 任务运行，和BSD 部分驻留在相同的地址空间中（应用程序空间）。&lt;/p&gt;
&lt;p&gt;直至 Mach Ten，Mac OS X 整合了 Mach、BSD、Macintosh 技术，虽然现代 Macintosh 是协作式多任务，但在 Mach Ten 中，Mac OS 是本地一等公民，而 Unix 运行在 UVM 虚拟机中，保持抢占式多任务执行 C 语言库、POSIX 子系统、BSD 网络栈、文件系统、RPC、NFS、X Windows。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;大融合&lt;/h2&gt;
&lt;p&gt;这就是 OPENSTEP 被作为现代 Mac OS 之前发生的事情，随后 NeXT 被引入苹果重新制订战略的故事。苹果公司收购 NeXT 的 OPENSTEP 可谓神来之笔，我们说那是 Mac OS 前世发生的一些事，下面即将讲述 NeXT 技术如何逐步进入 Apple 进化为现代 Mac OS 的底层。&lt;/p&gt;
&lt;p&gt;现代公司收购很多都失败了，比如 Microsoft 和 Nokia，其实很类似 Apple 收购 NeXT，前者多金，后者有出色的软件硬件，收购在预期上可实现双赢。但微软在手机战略上失败了，而 搭载苹果 Mac OS 的 Macintosh 虽然依然是小众，但其工业设计出色，是口碑绝顶的产品，在桌面市场的份额是逐步增加的。&lt;/p&gt;
&lt;p&gt;说回收购以后，苹果制订了两条腿走路的战略：针对消费者市场的 Mac OS 7.6 改进和针对企业服务市场的基于 NeXT 技术的高端操作系统 Rhapsody，代号 Copland（8）、Gershwin（9）。Copland 和 Gershwin 这两个单词来自美国本土音乐，后者正是《蓝色狂想曲》的作曲家，古典融合爵士元素，象征着 Macintosh 与 NeXT 的大融合。&lt;/p&gt;
&lt;p&gt;苹果操作系统的 7.6 版本是第一个称之为 Mac OS 的版本，它是一个32位兼容机系统，也是一个对敌 Windows 95 和 Internet 技术的版本。它在多方面得到了增强，比如：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;内存管理&lt;/li&gt;
&lt;li&gt;程序启动&lt;/li&gt;
&lt;li&gt;文件管理器缓存&lt;/li&gt;
&lt;li&gt;QuickTime&lt;/li&gt;
&lt;li&gt;完整的 TCP/IP 协议栈&lt;/li&gt;
&lt;li&gt;PPP（点对点协议）&lt;/li&gt;
&lt;li&gt;远程访问&lt;/li&gt;
&lt;li&gt;Mac OS 8&lt;/li&gt;
&lt;li&gt;Mac OS 8 内部版本号是 7.7，它包括：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多线程的 Finder，允许同时操作多个文件。本文要吐槽的操作方式可能就是这个时代引入的，那时的鼠标的上半部分只有一枚按键，即现在的鼠标左键，当按住键盘 control 键，单击时，系统会弹出一个现在的右键菜单，这个操作方式现在依然适用，这说明这部分代码的运行机制依然没有变化。
免费的微软 Internet Explorer 和 Netscape Navigator 浏览器，那时候还是一个大多软件要卖钱的时代，免费和捆绑策略让微软获得了竞争优势。
个人 Web 服务器，在个人站长时代，笔者也就是在那个时代走上 IT 之路的。
内置 Java，Java 语言确实是免费而久经考验。
电源管理、USB 等硬件增强。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mac-os-9"&gt;
&lt;h2&gt;Mac OS 9&lt;/h2&gt;
&lt;p&gt;Mac OS 9 在 1999 年发布，它实现了：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;操作系统在线升级&lt;/li&gt;
&lt;li&gt;Keychain，即大家常用的钥匙串，如果增强一下，就没有 1Password 啥事了。&lt;/li&gt;
&lt;li&gt;Carbon API，70% 与旧 Mac OS API 兼容，这是一次重要的梳理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2001 年 Mac OS 发布了 9.2.2，这是最后一个经典 Mac OS 版本，我们把 Mac OS 此版本以前的版本叫做 Mac OS Classic，即 Mac OS 的前世。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rhapsody"&gt;
&lt;h2&gt;Rhapsody&lt;/h2&gt;
&lt;p&gt;再来讲 Mac OS X 这条线。我把 Mac OS X 版本看作它的今生，这一切开始于 1997 年 WWDC，苹果演示了 Rhapsody 系统。它包括：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;内核是 Mach 和 BSD 4.3&lt;/li&gt;
&lt;li&gt;Blue Box：即 Mac OS 兼容子系统，演化为 Carbon API&lt;/li&gt;
&lt;li&gt;Yellow Box：OPENSTEP 技术资产，演化为 Cocoa API&lt;/li&gt;
&lt;li&gt;Java 虚拟机&lt;/li&gt;
&lt;li&gt;基于 Display PostScript 的窗口系统&lt;/li&gt;
&lt;li&gt;用户界面类似原 Mac OS，但也有些像 OPENSTEP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在最新的 WWDC App 上，可追溯的历史只到 2014 年，真希望苹果能把早年的 WWDC 也放上来。上述技术中，Blue Box 应该有人用过，即 Classic Startup.app 中可以运行，也可能有人玩过 Yellow Box，可以安装在 Windows 上。&lt;/p&gt;
&lt;p&gt;Rhapsody 包含 DR1 和 DR2 两个版本，DR2 吸纳了 FreeBSD、NetBSD 的代码，并将其中的分支开源为 Darwin 项目，这个举措让苹果和开源社区之间获得了双赢，现在你可以在 GNU Darwin 找到它，并可下载源码，另一个 Open Darwin 项目如今已关闭。Rhapsody 就像一个超新星爆发般， 1999 年 3 月以 Mach 3 为基础推出了 Mac OS X Server 1，就是改名的 Rhapsody DR3。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mac-os-x-beta"&gt;
&lt;h2&gt;Mac OS X Beta&lt;/h2&gt;
&lt;p&gt;此时的 Apple Mac OS X Public Beta 离正式与公众见面还有 3 年的路程，中间包括 DP1、DP2、DP3、DP4 四个迭代（DP 即 开发者预览版）。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;DP1：这是一个 Carbon API 梳理版本，且为了过度，需要实现新旧两个目标平台的编译。&lt;/li&gt;
&lt;li&gt;DP2：引入了更多 API，如 BSD、Carbon、Classic、Cocoa 和 Java。从后面的发展来看，Carbon 有的，Cocoa 终会逐渐取代，但马戏团后台的升级不是一刀完成，而是保持前台不变的前提下，后台一直在工作。苹果公司精通渐进式演化之道。&lt;/li&gt;
&lt;li&gt;DP3：后台功能强了，但根据反馈，用户不满意界面，因此此版本推出了 Aqua 用户界面，就是现在大家熟悉的红、黄、绿三色交通灯窗口，水的元素，以及图标扩大为 128 * 128。&lt;/li&gt;
&lt;li&gt;DP4：将 Finder.app 拆分为 Desktop.app 和 Docker.app，并引入了第一次引入了系统设置，它提供一个用户界面来让用户调节系统的很多选项。还包括 Docker 的左右分栏和拖离云朵动画、OpenGL、和新的集成开发环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公众对不断透露的改进消息非常兴奋，但能接触的第一版本需要约 200 多元购买的。这个版本还通过 OpenDarwin 大量移植了开源资源，这也是很多开发人员觉得 Apple 比 Windows 更适合开发的原因。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mac-os-x"&gt;
&lt;h2&gt;Mac OS X&lt;/h2&gt;
&lt;p&gt;Mac OS X 10.0 可以说是 Apple 桌面操作系统历史上最高级的发布，它代表着 Apple 公司对研发资源的了解和对软件工程管理的进步。同所有软件一样，Mac OS 经历了 3-5 个小版本才逐渐完善，分别是：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Mac OS X 10.0 Cheetah&lt;/li&gt;
&lt;li&gt;Mac OS X 10.1 Puma&lt;/li&gt;
&lt;li&gt;Mac OS X 10.2 Jaguar&lt;/li&gt;
&lt;li&gt;Mac OS X 10.3 Panther&lt;/li&gt;
&lt;li&gt;Mac OS X 10.4 Tiger&lt;/li&gt;
&lt;li&gt;Mac OS X 10.5 Leopard&lt;/li&gt;
&lt;li&gt;Mac OS X 10.6 Snow Leopard&lt;/li&gt;
&lt;li&gt;Mac OS X 10.7 Lion&lt;/li&gt;
&lt;li&gt;OS X 10.8 Mountain Lion&lt;/li&gt;
&lt;li&gt;OS X 10.9 Mavericks&lt;/li&gt;
&lt;li&gt;OS X 10.10 Yosemite&lt;/li&gt;
&lt;li&gt;OS X 10.11 El Capitan&lt;/li&gt;
&lt;li&gt;macOS 10.12 Sierra&lt;/li&gt;
&lt;li&gt;macOS 10.13 High Sierra&lt;/li&gt;
&lt;li&gt;macOS 10.14 Mojave&lt;/li&gt;
&lt;li&gt;macOS 10.15 Catalina&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中经历了 OS X 和 macOS 的两次改名，第一次代表了与 iOS 的融合，第二次的命名方式为匈牙利表示法，可以感受一下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
    iOS
watchOS
   tvOS
     OS X
&lt;/pre&gt;
&lt;p&gt;有没有一种强迫症无法忍受的感觉:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
    iOS
watchOS
   tvOS
  macOS
&lt;/pre&gt;
&lt;p&gt;明显后者更和谐。&lt;/p&gt;
&lt;p&gt;其中，数 Tiger 的更新比较多，大家熟知的 Automator、Spotlight、Dashboard 就是此时引入的。后面的每个版本更新都具有很多经典之处，图标也趋于扁平化，适应这个信息繁杂的时代。&lt;/p&gt;
&lt;p&gt;如果把 Apple 桌面操作系统历史对比人类历史，那从古代到近代史部分就已经说完了。其现代史部分以近 5 年为分水岭，2014 年以后的发布都可以在 Apple WWDC App 中查阅。笔者也会在其他文章中穿插许多有趣的 Apple 操作系统细节，以下附送体系结构图一张。&lt;/p&gt;
&lt;img alt="macOS 体系结构" src="https://kaffa.im/img/2019/macos-structure.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;啊哈！到了本文附送的技巧。&lt;/h2&gt;
&lt;p&gt;终于说到了在访达（Finder）中拷贝文件的路径的方法，有如下几种：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;方法一：访达应用中，可以点击菜单【显示】【显示路径栏/隐藏路径栏】，打开位于底部状态栏上方的路径栏，鼠标右键点击“将（路径）拷贝为路径名称”即可。&lt;/li&gt;
&lt;li&gt;方法二：打开一个终端应用，将文件夹或文件拖入，既可以得到路径，选中后拷贝即可。&lt;/li&gt;
&lt;li&gt;方法三：网上提到的在自动操作应用中新建一个服务的方式，这种其实对某些文件夹并不好使。&lt;/li&gt;
&lt;li&gt;方法四：此方法的交互设计比较隐藏，但唾手可得，即右键点击想要拷贝路径的目录或文件，在弹出菜单时，按住键盘 option/alt 键，此时菜单中的拷贝“（路径）”会变成将“（路径）”拷贝为路径名称。这种设计有点绕，但是比较高效了。&lt;/li&gt;
&lt;li&gt;方法五：快捷键 ⌥⌘C（评论提供），此种最高效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好吧，虽然这楼歪的很，但技巧确实附送了，是吧？&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="macOS"></category><category term="Mac OS"></category><category term="macOS History"></category><category term="Machintosh"></category><category term="BeOS"></category><category term="NeXT"></category><category term="OPENSTEP"></category><category term="Mach"></category></entry><entry><title>修改 Microsoft Code Markdown 格式的快捷键</title><link href="https://kaffa.im/change-font-bold-keyborad-shortcuts-in-code-markdown-mode.html" rel="alternate"></link><published>2019-05-15T12:00:00+08:00</published><updated>2019-05-15T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-05-15:/change-font-bold-keyborad-shortcuts-in-code-markdown-mode.html</id><summary type="html">&lt;p&gt;修改 Microsoft Code Markdown 格式的快捷键&lt;/p&gt;</summary><content type="html">&lt;p&gt;为了兼容 macOS 系统 MWeb 写作，我将文档格式从 .rst 修改为了 .md。我选择 Microsoft Code Markdown 来写日志，但发现快捷键 Ctrl + B 并不能将文字加粗。&lt;/p&gt;
&lt;p&gt;进入【File】【Preferences】【Keyborad Shortcuts】，搜索 Ctrl + B，发现默认关联很多其他功能，比如调试断点（Breakpoint）和隐藏边栏。&lt;/p&gt;
&lt;p&gt;经过把 Ctrl + H 换成 Ctrl + R，把隐藏边栏 Ctrl + B 换成 Ctrl + H，编辑 Markdown 文件中的 Ctrl + B 成为了加粗的快捷键。&lt;/p&gt;
&lt;p&gt;Microsoft Code 这个披着 IDE 外衣的编辑器，还是需要细致调教才会变得好用的，&lt;strong&gt;多人设计插件的快捷键重复问题是因缺乏统一的规范和检查机制导致的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" title="我的赞赏码" /&gt;&lt;/p&gt;</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category></entry><entry><title>关于计算机科学</title><link href="https://kaffa.im/about-computer-science.html" rel="alternate"></link><published>2019-04-24T12:00:00+08:00</published><updated>2019-04-24T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-04-24:/about-computer-science.html</id><summary type="html">&lt;p&gt;简单讲述计算机科学和工程科学的理解&lt;/p&gt;</summary><content type="html">&lt;p&gt;首先我想说说心理学。&lt;/p&gt;
&lt;p&gt;人们对世界好奇、追寻和探索，其间总会发现，许多疑问和障碍并不在外部，而在于内在。所以，德尔菲神庙上镌刻着阿波罗神谕“认识你自己”。人类对内在心灵、灵魂的探索最初来自于宗教、神学和哲学，那些认知的结论，在许多世纪之前，类似强力的光柱透过彩窗从不同角度射入黑暗将空间照亮，人们从不同面提出对这门学科的理解。&lt;/p&gt;
&lt;p&gt;直到冯特采用科学实验的方式进行心理研究才奠定现代意义的心理学基础，它研究人的心灵和行为的关系，其建构在科学实验和行为统计之上，现代前沿的是实验心理学和认知心理学。很多研究，比如对神经元和人类学习的研究，直接促成了模式匹配、机器统计学习和人工神经网络的发展。&lt;/p&gt;
&lt;p&gt;科学在高处相通，从学科的分层，心理学分为理论心理学和应用心理学，而计算机科学也可分为理论部分和应用部分。&lt;/p&gt;
&lt;p&gt;从理论部分说，计算机科学是通过理论计算机研究信息处理的科学，其实和实体计算机的关联并不大，它更偏向于数学、逻辑、计算理论和信息理论。&lt;/p&gt;
&lt;p&gt;由于计算科学和信息科学并不在大众常识范围内，所以大多数人的理解，学计算机科学毕业，大约应该是学会了装电脑用。:-(&lt;/p&gt;
&lt;p&gt;从应用层面说，计算机科学又包含，计算机工程学和商业计算机系统。前者是研究计算机硬件和集成固件，后者是信息系统。&lt;/p&gt;
&lt;p&gt;现代，数据、信息和计算如此重要，计算机应用几乎能和所有学科交叉、相互促进。&lt;/p&gt;
&lt;p&gt;现代计算机硬件和操作系统软件的出现是理论计算机和计算机工程学的完美配合，前者是说邱奇-图灵的图灵机和可计算性理论，后者是说冯·诺依曼和 ENIAC，第一台存储程序计算机模型的大型计算机。&lt;/p&gt;
&lt;p&gt;也许大多数人觉得计算机能计算处理信息不可思议，但除开电器层次和复杂性，在其本质上，依旧还是图灵的代表0和1的无限伸展的纸带和冯·诺依曼对理论计算机的工程实现。&lt;/p&gt;
&lt;p&gt;发展了 80 多年的计算科学，其实核心一成不变，是的，毫不令人惊讶，因为世界降生一位像图灵一样，有野心、有才华、还努力、还开挂的天才并不容易，只有这样的天才的头脑中，才会诞生理论计算机。&lt;/p&gt;
&lt;p&gt;为什么计算的核心一成不变，其实中国《易经》六十四卦即类似的算法表述——二分法（将在未来专写一篇），也是超越各种语言和思维的通用思维方式。&lt;/p&gt;
&lt;p&gt;这就是——易——宇宙的逻辑，无论事物表像多么的不同。&lt;/p&gt;
&lt;p&gt;此处，作个总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算机科学：Computer Science，简称 CS&lt;/p&gt;
&lt;p&gt;所有有关计算机科学及子学科的总称，是系统性研究信息与计算的理论基础以及计算机系统实现与应用的技术学科。现代主要研究领域有：
* 人工智能
* 计算机体系结构
* 人机交互
* 软件工程
* 数据与数据库
* 多媒体（计算机图形学）
* 网络
* 信息安全
* 管理信息系统
* 生物信息
* 计算理论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电子工程：Electronic Engineering，简称 EE&lt;/p&gt;
&lt;p&gt;以电子学、电磁学等物理学分支为基础，涵盖电子学、电子计算机的工程学。主要的研究分支：
* 通信与网络
* 信号处理
* 电子学
* 集成电路
* 光电子与光学&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件工程学：Software Engineering，简称 SE&lt;/p&gt;
&lt;p&gt;研究如何以科学过程和方法去开发和维护软件的科学，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最佳实践结合起来的学科。是CS的分支领域，该方向因为开发软件和软件项目变得很热门，也是跟软件工程师最近的方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息技术：Information Technology，简称 IT&lt;/p&gt;
&lt;p&gt;主要用上述学科知识应用到具体行业，开发、安装和实施信息系统及应用软件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;无论承不承认，上述四个方向其实是具有线性关系的。&lt;/p&gt;
&lt;p&gt;感谢各位大佬围观。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" title="我的赞赏码" /&gt;&lt;/p&gt;</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="计算机科学"></category><category term="Computer Science"></category><category term="电子工程"></category><category term="Electronic Engineering"></category><category term="软件工程学"></category><category term="Software Engineering"></category><category term="信息技术"></category><category term="Information Technology"></category></entry><entry><title>关于滑块验证码的思路</title><link href="https://kaffa.im/some-thoughts-on-reCAPTCHA.html" rel="alternate"></link><published>2019-04-17T12:00:00+08:00</published><updated>2019-04-17T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2019-04-17:/some-thoughts-on-reCAPTCHA.html</id><summary type="html">&lt;p class="first last"&gt;本文描述关于自动通过滑块验证码验证的思路&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id2"&gt;
&lt;h2&gt;图灵测试&lt;/h2&gt;
&lt;p&gt;图灵测试是一个著名的思想实验，它要解决的问题是如何判断一台机器是否具有智能。&lt;/p&gt;
&lt;p&gt;简单的讲，就是把判定对象看做黑盒，人与其对话，如果人分辨不出被判定对象是否是机器的话，就算它通过了图灵测试。&lt;/p&gt;
&lt;p&gt;而“&lt;a class="reference external" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%87%E6%88%BF%E9%97%B4"&gt;中文房间&lt;/a&gt;”思想实验，即呈现了图灵测试的局限——即使机器实现了智能外在的输入输出，内在结构也可以不是智能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;滑块验证码&lt;/h2&gt;
&lt;p&gt;软件安全技术的攻击与防守就好比矛和盾，随着技术的更新，此消彼长。&lt;/p&gt;
&lt;p&gt;由于自动化技术的发展，脚本加本地代码已可以解决没有技术门槛的人类验证。二十年前，只要懂脚本，就可以让计算机自动做很多事；十六年前，Luis 在发明了验证码，
我也曾在 Google Code 中下载 &lt;a class="reference external" href="https://code.google.com/archive/p/tesseract-ocr/"&gt;tesseract-ocr&lt;/a&gt; 以解决中文验证码，但 Gooogle 的 reCAPTCHA 确实很扭曲，却是鲜有人破解。&lt;/p&gt;
&lt;p&gt;但随着 AI 机器学习技术的发展，扭曲文字的自动识别难点已被攻破。在多年前的某天，滑块验证码出现了，技术社区讨论如火如荼。&lt;/p&gt;
&lt;p&gt;稍微几年未关注，这个领域除了巨头，还产出了 API 售卖 reCAPTCHA 的小而美的公司，比如`极验`_。&lt;/p&gt;
&lt;p&gt;GitHub 中也有不少破解其旧版本的代码，虽然没有查看其新版本，但可以简单谈谈绕过的思路。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;解决思路&lt;/h2&gt;
&lt;p&gt;可以从网络层、系统层和用户层来考虑：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;网络层：此类验证，最后发送的数据一定需要加密，难点在于对付 js 的混淆，通过单步调试找到加密前的数据。理解数据，或直接采集多组数据，再模拟发送即可。这一种思路对耐心的要求很高。&lt;/li&gt;
&lt;li&gt;系统层：通过程序抓图和图像运算比对，计算出键盘鼠标的操作即可，这一种相对比较容易，但速度不如网络层解决快。&lt;/li&gt;
&lt;li&gt;用户层：采用软硬件结合的极客思路，用摄像头进行视觉采集，用机器手操纵鼠标，完全模拟一个有智能的会操作键盘和鼠标的人，这种可能是最一劳永逸，但门槛最高的思路。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="GeeTest"></category></entry><entry><title>知识斜杆及丁福保</title><link href="https://kaffa.im/multiple-careers-and-ding-fu-bao.html" rel="alternate"></link><published>2018-10-01T12:00:00+08:00</published><updated>2018-10-01T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-10-01:/multiple-careers-and-ding-fu-bao.html</id><summary type="html">&lt;p&gt;记录一位知识斜杆——丁福保&lt;/p&gt;</summary><content type="html">&lt;h2&gt;斜杆&lt;/h2&gt;
&lt;p&gt;斜杆这个词，从 2007 年被 Marci Alboher 写入《One Person / Multiple Careers》到知识付费时代的走红，整整花了 12 年。曾几何时，当“演员 / 歌手 / 环保主义者 / 爱心大使”黄晓明老师还在马爹利 XO 广告 NG 时，知识管理专家&lt;a href="https://www.douban.com/people/qsxiao/"&gt;萧秋水&lt;/a&gt;老师还在新浪更新微博，粉丝们也还听不到&lt;a href="https://www.ximalaya.com/jiaoyu/5200130/"&gt;“学会知识管理，优秀到不能被忽视”&lt;/a&gt;，还不理解斜杠的一专多能。不过，我想世上有的 10 种人之一中的大多数应该明白：yourTags.split('/')[0] 才最重要。想到译言、字幕组及 0Day Group，毫无疑问其中的大多数都是可以斜杆的青年。今天要说的就是无意间认识的一位生于民国的知识斜杆——丁福保。&lt;/p&gt;
&lt;p&gt;出于对古旧物的偏爱，父亲让我为他买一本丁福保著&lt;a href="https://book.douban.com/subject/2338993/"&gt;《历代古钱图说》&lt;/a&gt;一版一印。我在孔夫子网询问了二十多位卖家，只找得到一版二印。记得小时候父亲买过一本，定价是十元不到，后来可能是遗失了。今天查找资料时发现，丁福保不只是民国一位古币收藏家，更是一位知识斜杆。试着摘录维基关于&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%81%E7%A6%8F%E4%BF%9D"&gt;丁福保&lt;/a&gt;的介绍，随意感受一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;丁福保（1874年6月22日－1952年11月28日），字仲祐，号畴隐居士，籍贯江苏常州，生于无锡。中华民国及中华人民共和国佛教居士，翻译家，古钱币、古籍收藏家，医生。

幼通经史，长而中西兼贯，长于算术、医学、词章、考据，通日文。光绪二十二年补无锡秀才。

25岁就读于江阴南菁书院。28岁东吴大学肄业。同年，到上海江南制造局工艺学堂学化学，入东文学堂学日文，又师从赵元益学医，学成，任京师大学堂及译学馆教习。

1909年赴日考察医学，后于上海行医并创办医学书局。

1914年始向佛。著作分为医学、文学、进德、佛学、钱币学等丛书。先后出版《一切经音义提要》、《佛经精华录笺注》、《六祖坛经笺注》、《心经笺注》、《六道轮回录》、《佛学指南》、《佛学起信论》、《说文解字诂林补遗》、《古钱大辞典》、《古泉学纲要》等著作。

1952年，福保因老衰在上海逝世，享年79岁。他一生著述等身，最著名的是《佛学大辞典》，此书译自日本人织田得能的《佛学大辞典》，系删除了日本佛教相关资料及文献出处所成的节译本。

丁福保有子丁惠康，亦为收藏家、医学家。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://baike.baidu.com/item/%E4%B8%81%E7%A6%8F%E4%BF%9D"&gt;百度百科&lt;/a&gt;还提到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;丁福保，字仲祜，别号畴隐居士，又号济阳破衲，原籍江苏常州，清同治十三年(1874)6月22日生于无锡。1918年就编有《历代医学书目提要》，后又与人合编《四库总录医药编》，兼收中外医学书籍。

辛亥革命前后，编辑刊印有《汉魏六朝名家集初刻》、《全汉三国晋南北朝诗》、《历代诗语续编》、《清诗话》等数部丛书。喜藏书，早年仰慕南菁书院藏书，曾手抄书院目录1册，以备购藏。

1924年自称藏有“十万又三千”卷书，建“诂林精舍”，吴稚晖题写匾额，藏书总数达15万余卷。捐献藏书众多，先后捐给无锡县图书馆、县立第一小学图书馆1868种，22904卷。

1935年他曾捐给上海市立图书馆图书15000册；

1938年捐入震旦大学2万册，5万余卷古今刊本，该校设立“丁氏文库”以志纪念。

1000余册古籍则捐入北京图书馆，其中包括购自常熟“铁琴铜剑楼”的宋元古本10余种。

所藏书未见编撰书目，藏书出售时，上海存古书店编有《无锡丁氏珍藏善本书目》，著录了600余种、16 000余册善本。编著有《文选类诂》、《尔雅诂林》、《说文解字诂林》、《无锡丁氏藏书志》、《古钱大辞典》等。

1952年11月28日，丁福保因病在上海去世，终年78岁。生前编成而未及出版的《四部总录》遗稿经其学生周云青整理后，由商务印书馆出版了“医药编”、 “天文编”、“算法编”、“艺术编”4种。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见，丁福保国学基础好，又爱钻研训诂学，爱好藏书，整理古籍20多年，印刷发行多种大型图书，去世后，其书籍众数捐献给国家。可谓知识斜杆，跨领域大师，功德无量。Perfect，完美的一生。&lt;/p&gt;
&lt;p&gt;其子，承继父业，亦为斜杆：收藏家 / 医学家。有时候，把一个青年变成斜杆的，不是他自己，而是人生。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" title="我的赞赏码" /&gt;&lt;/p&gt;</content><category term="随笔"></category><category term="Essays"></category><category term="阅读"></category><category term="Reading"></category><category term="Multiple Careers"></category></entry><entry><title>Jekyll、MSYS2、Vibora 及在 Windows 下用 Linux</title><link href="https://kaffa.im/jekyll-msys2-vibora-and-use-linux-on-windows.html" rel="alternate"></link><published>2018-08-14T12:00:00+08:00</published><updated>2018-08-14T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-08-14:/jekyll-msys2-vibora-and-use-linux-on-windows.html</id><summary type="html">&lt;p class="first last"&gt;本文聊聊 Jekyll、MSYS2、Vibora 及在 Windows 下用 Linux 的话题&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;故事&lt;/h2&gt;
&lt;p&gt;故事开始于我需要在 Windows 下用 Jekyll 转化一篇 Markdown 的博文，于是在 Windows 下安装了 Jekyll，其中涉及一些 MSYS2 的安装坑。
接下来想到 MSYS2 其实可以解决 Vibora 的问题，于是将这两个过程中的难点记录一下，再谈谈在 Windows 下使用 Linux 的话题。&lt;/p&gt;
&lt;p&gt;本文旨在为正使用 Windows 同时又想使用 Linux 功能的人列举一些可能的途径，本文适用于对 Windows 和 Linux 具备一定了解的人。
另有计划写 Windows、macOS、Linux 操作系统比较的博文，但本文的范围不涉及比较。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="widnows-jekyll"&gt;
&lt;h2&gt;Widnows 下用 Jekyll&lt;/h2&gt;
&lt;p&gt;Jekyll 依赖于 Ruby Runtime 和一些 Gem 包，而 Ruby Runtime 在 Windows 下推荐用于 &lt;a class="reference external" href="https://rubyinstaller.org/"&gt;RubyInstaller&lt;/a&gt;，
某些 Gem 包需要本地编译，官方推荐 &lt;a class="reference external" href="http://www.msys2.org/"&gt;MSYS2&lt;/a&gt; 安装 Windows 上的编译工具链。
因为众所周知的原因，国内安装这些软件时也会遇到一些问题。下面叙述步骤并给予问题的解决办法。&lt;/p&gt;
&lt;div class="section" id="ruby"&gt;
&lt;h3&gt;安装 Ruby&lt;/h3&gt;
&lt;p&gt;运行下载好的 RubyInstaller，基于少一层目录的原因，建议直接安装在根目录下，例如 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\Ruby25\&lt;/span&gt;&lt;/tt&gt;，并将此目录加入安装目录到 PATH。在最后点击结束按钮后，会提示安装 MSYS2，它用来编译 Ruby 本地包，官方说它的下载由一个全球 CDN 提供，但它在国内的访问真是无力吐槽。&lt;/p&gt;
&lt;p&gt;也许你等待龟速网络很久可以将 MSYS2 安装成功，也许你会遭遇反复失败，不知如何是好。但如果你需要使用 Jekyll，而它使用了本地二进制包，那么这个问题是无法跳过的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="msys2"&gt;
&lt;h3&gt;安装 MSYS2 的小技巧&lt;/h3&gt;
&lt;p&gt;如果你跳过了 MSYS2 安装，那么在后续的 gem install 时，会提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MSYS2 could not be found. Please run &amp;#39;ridk install&amp;#39; or download and install MSYS2 manually from https://msys2.github.io/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你执行 &lt;tt class="docutils literal"&gt;ridk install&lt;/tt&gt; 时，会显示下载 &lt;a class="reference external" href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20180531.exe"&gt;http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20180531.exe&lt;/a&gt; 失败，我的解决办法是用迅雷下载 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;msys2-x86_64-20180531.exe&lt;/span&gt;&lt;/tt&gt;，并用 IIS 或 Apache 等服务器，在本地配置一个站点下载，这样做需要管理员权限修改 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\Windows\System32\drivers\etc\hosts&lt;/span&gt;&lt;/tt&gt; 文件，临时加入一行配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;127.0.0.1    repo.msys2.org
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时确保访问 &lt;a class="reference external" href="http://127.0.0.1/distrib/x86_64/msys2-x86_64-20180531.exe"&gt;http://127.0.0.1/distrib/x86_64/msys2-x86_64-20180531.exe&lt;/a&gt; 时可以正常下载。那么再次运行 &lt;tt class="docutils literal"&gt;ridk install&lt;/tt&gt; 时，就会通过本机下载了。&lt;/p&gt;
&lt;p&gt;然后，当 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;msys2-x86_64-20180531.exe&lt;/span&gt;&lt;/tt&gt; 下载完毕时，需要及时把上述 hosts 配置行删除，因为本机并没有 &lt;tt class="docutils literal"&gt;repo.msys2.org&lt;/tt&gt; 站点下的其他文件。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;配置 MSYS2 镜像地址&lt;/h3&gt;
&lt;p&gt;同时，为了 MSYS2 其他包方便下载，建议配置国内镜像，分别修改下面三个文件，在配置的最上加入 清华大学 与 中科大镜像地址&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\msys64\etc\pacman.d\mirrorlist.mingw64&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;##
## 64-bit Mingw-w64 repository mirrorlist
##
## 清华大学软件镜像
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/
## 中科大镜像
Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\msys64\etc\pacman.d\mirrorlist.mingw32&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;##
## 32-bit Mingw-w64 repository mirrorlist
##
## 清华大学软件镜像
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/
## 中科大镜像
Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\msys64\etc\pacman.d\mirrorlist.msys&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;##
## MSYS2 repository mirrorlist
##
## 清华大学软件镜像
Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/
## 中科大镜像
Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你及时删除了 hosts 文件中的配置行，那么 NSYS2 即可以顺利完成安装。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;测试 MSYS2 安装是否成功&lt;/h3&gt;
&lt;p&gt;可以再次运行 &lt;tt class="docutils literal"&gt;ridk install&lt;/tt&gt;，命令行会打开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;RubyInstaller2 for Windows

1 - MSYS2 base installation
2 - MSYS2 system update
3 - MSYS2 and MINGW development toolchain
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;试试 1、2、3 三个选项，如果全部没有可更新项时，就证明 MSYS2 安装已经成功了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gem"&gt;
&lt;h3&gt;配置 Gem 镜像地址&lt;/h3&gt;
&lt;p&gt;对于有价值的开源技术，国内一般都进行了镜像，一般都建议直接使用国内镜像地址。运行下面命令配置镜像&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gem sources –r https://rubygems.org/
gem sources -a https://ruby.taobao.org/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行下面命令查看，并更新&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gem sources -l
gem update
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="jekyll"&gt;
&lt;h3&gt;安装 Jekyll&lt;/h3&gt;
&lt;p&gt;下面是官方网站优雅的几行介绍&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~ $ gem install bundler jekyll
~ $ jekyll new my-awesome-site
~ $ cd my-awesome-site
~/my-awesome-site $ bundle exec jekyll serve
# =&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; Now browse to http://localhost:4000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了上面步骤的铺垫，至此，Jekyll 可以优雅的运行了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3&gt;关于 Ruby 的感叹&lt;/h3&gt;
&lt;p&gt;十年前，曾在 Ruby 语言通过 Web 2.0 的需求爆发时，借 Web 敏捷框架 Rails 大红大紫了解过它，对这些年一直没有再有机会使用，如果没有 Rails，Ruby 就不会红，定位于 Python 和 Perl 之间，如今它也许会有所发展，但综合来看，都会逐渐变成先前使用了 RoR 公司的技术遗产，市场上 Ruby 的技术人员也会越来越少，加上它本身并未和现在大前端、移动互联网、大数据、云计算、人工智能、VR等任何一个热点沾边，也不具备后端编译语言的规模成本优势，从系统论视角思考，没有生态，就会走向低谷，但在它擅长的 Web 领域内，还是一种有智慧的解决方案。&lt;/p&gt;
&lt;p&gt;相比来说，经常能先于时代的 Python 的好运气并不是偶然，因为重视科研领域，它借着大数据分析和人工智能一飞冲天，如今生态广阔的 Python，相比来说就有着更稳固的护城河，这种就好比持续增长的公司拥有的竞争优势一样，更值得长期看好。所以，下面就说说 Python Web Framework：Vibora&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="widnows-vibora"&gt;
&lt;h2&gt;Widnows 下用 Vibora&lt;/h2&gt;
&lt;p&gt;Vibora 性能闪瞎眼，为了不让 MSYS2 环境浪费，于是尝试是否可以通过 MSYS2 将它运行起来。&lt;/p&gt;
&lt;div class="section" id="msys2-python3"&gt;
&lt;h3&gt;MSYS2 安装 python3&lt;/h3&gt;
&lt;p&gt;首先，打开 MSYS2 运行 python 或 python3，提示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-bash: python: 未找到命令
-bash: python3: 未找到命令
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是我们需要在 MSYS2 中添加软件包，请出 pacman，它移植于著名 LFS ———— Arch Linux 发行版&lt;/p&gt;
&lt;p&gt;首先，安装一些依赖和编译工具&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pacman --needed -Sy bash pacman pacman-mirrors msys2-runtime
pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-gdb mingw-w64-x86_64-make tmux zsh git mingw64/mingw-w64-x86_64-cmake winpty
pacman -S mingw-w64-x86_64-python3-bsddb3 mingw-w64-x86_64-gexiv2 mingw-w64-x86_64-ghostscript mingw-w64-x86_64-python3-cairo mingw-w64-x86_64-python3-gobject mingw-w64-x86_64-python3-icu mingw-w64-x86_64-iso-codes mingw-w64-x86_64-hunspell mingw-w64-x86_64-hunspell-en mingw-w64-x86_64-enchant
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来安装 python3 和 pip3&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pacman -S mingw-w64-x86_64-python3
pacman -S python3-pip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时 python3 和 pip3 已经安装，顺便把 pip3 升个级，最近它的版本号也像 Chrome 一样一发不可收拾。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip3 install --upgrade pip
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="msys2-vibora"&gt;
&lt;h3&gt;MSYS2 安装 vibora&lt;/h3&gt;
&lt;p&gt;再安装 vibora&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip3 install vibora
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提示错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Running setup.py install for vibora ... error
Complete output from command /usr/bin/python3 -u -c &lt;span class="s2"&gt;&amp;quot;import setuptools, toke&lt;/span&gt;
nize;__file__=&amp;#39;/tmp/pip-install-rawskw89/vibora/setup.py&amp;#39;;f=getattr(tokenize, &amp;#39;o
pen&amp;#39;, open)(__file__);code=f.read().replace(&amp;#39;\r\n&amp;#39;, &amp;#39;\n&amp;#39;);f.close();exec(compile
&lt;span class="p"&gt;(&lt;/span&gt;code, __file__, &amp;#39;exec&amp;#39;&lt;span class="p"&gt;)&lt;/span&gt;)&lt;span class="s2"&gt;&amp;quot; install --record /tmp/pip-record-9rnpdvhe/install-rec&lt;/span&gt;
ord.txt --single-version-externally-managed --compile:

...

unable to execute &amp;#39;x86_64-pc-msys-gcc&amp;#39;: No such file or directory
error: command &amp;#39;x86_64-pc-msys-gcc&amp;#39; failed with exit status 1

...

Command &lt;span class="s2"&gt;&amp;quot;/usr/bin/python3 -u -c &amp;quot;&lt;/span&gt;import setuptools, tokenize;__file__=&amp;#39;/tmp/pip-
install-rawskw89/vibora/setup.py&amp;#39;;f=getattr(tokenize, &amp;#39;open&amp;#39;, open)(__file__);co
de=f.read().replace(&amp;#39;\r\n&amp;#39;, &amp;#39;\n&amp;#39;);f.close();exec(compile(code, __file__, &amp;#39;exec&amp;#39;)
)&lt;span class="s2"&gt;&amp;quot; install --record /tmp/pip-record-9rnpdvhe/install-record.txt --single-version&lt;/span&gt;
-externally-managed --compile&lt;span class="s2"&gt;&amp;quot; failed with error code 1 in /tmp/pip-install-raws&lt;/span&gt;
kw89/vibora/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想来原因是 Vibora 依赖本地二进制程序进行异步通信。&lt;/p&gt;
&lt;p&gt;再安装 x86_64-pc-msys-gcc&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pacman -S gcc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后，再次运行 &lt;tt class="docutils literal"&gt;pip3 install vibora&lt;/tt&gt;，提示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In file included from vibora/parsers/parser.c:4:0:
/usr/include/python3.6m/Python.h:39:10: 致命错误：crypt.h：No such file or d
irectory
 #include &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;crypt.h&amp;gt;
          &lt;span class="se"&gt;^~&lt;/span&gt;~~~~~~~
编译中断。
error: command &amp;#39;x86_64-pc-msys-gcc&amp;#39; failed with exit status 1

----------------------------------------
Command &lt;span class="s2"&gt;&amp;quot;/usr/bin/python3 -u -c &amp;quot;&lt;/span&gt;import setuptools, tokenize;__file__=&amp;#39;/tmp/pip-install-t22lx1u7/vibora/setup.py&amp;#39;;f=getattr(tokenize, &amp;#39;open&amp;#39;, open)(__file__);code=f.read().replace(&amp;#39;\r\n&amp;#39;, &amp;#39;\n&amp;#39;);f.close();exec(compile(code, __file__, &amp;#39;exec&amp;#39;))&lt;span class="s2"&gt;&amp;quot; install --record /tmp/pip-record-f8i8_k06/install-record.txt --single-version-externally-managed --compile&amp;quot;&lt;/span&gt; failed with error code 1 in /tmp/pip-install-t22lx1u7/vibora/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StackOverflow 大法好，提示缺少的 头文件 crypt.h 在 libcrypt-devel 包中，于是再安装 x86_64-pc-msys-gcc&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pacman -S libcrypt-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三次运行  &lt;tt class="docutils literal"&gt;pip3 install vibora&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ pip3 install vibora
Collecting vibora
Using cached https://files.pythonhosted.org/packages/1c/db/c42998b106b89d67ce0                                            fe256320454ca224e4d3d05f56dd518514a5b738c/vibora-0.0.6.tar.gz
Requirement already satisfied: pendulum in /usr/lib/python3.6/site-packages (from vibora) (2.0.3)
Requirement already satisfied: python-dateutil&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;3.0,&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;=2.6 in /usr/lib/python3.6/site-packages (from pendulum-&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;vibora) (2.7.3)
Requirement already satisfied: pytzdata&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;=2018.3 in /usr/lib/python3.6/site-packages (from pendulum-&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;vibora) (2018.5)
Requirement already satisfied: six&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;=1.5 in /usr/lib/python3.6/site-packages (from python-dateutil&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;3.0,&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;=2.6-&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;pendulum-&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;vibora) (1.10.0)
Installing collected packages: vibora
Running setup.py install for vibora ... done
Successfully installed vibora-0.0.6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的天，成功了！于是试了试官方 hello-world.py&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vibora-hello-world"&gt;
&lt;h3&gt;运行 vibora hello world&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;vibora&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Vibora&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;vibora.responses&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;JsonResponse&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vibora&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;home&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;JsonResponse&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0.0.0.0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;8000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;xxx@yyyy MSYS /d/code/vibora
$ python hello-world.py
Traceback (most recent call last):
File &lt;span class="s2"&gt;&amp;quot;hello-world.py&amp;quot;&lt;/span&gt;, line 1, in &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;module&amp;gt;
    from vibora import Vibora, Request
File &lt;span class="s2"&gt;&amp;quot;/usr/lib/python3.6/site-packages/vibora/__init__.py&amp;quot;&lt;/span&gt;, line 7, in &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;module&amp;gt;
    from .server import *
File &lt;span class="s2"&gt;&amp;quot;/usr/lib/python3.6/site-packages/vibora/server.py&amp;quot;&lt;/span&gt;, line 11, in &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;module&amp;gt;
    from .workers.handler import RequestHandler
File &lt;span class="s2"&gt;&amp;quot;/usr/lib/python3.6/site-packages/vibora/workers/handler.py&amp;quot;&lt;/span&gt;, line 3, in &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;module&amp;gt;
    from socket import IPPROTO_TCP, TCP_NODELAY, SO_REUSEADDR, SOL_SOCKET, SO_REUSEPORT, socket
ImportError: cannot import name &amp;#39;SO_REUSEPORT&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;google 错误提示，居然来到了 &lt;a class="reference external" href="https://github.com/vibora-io/vibora/issues/106"&gt;vibora-issues-106&lt;/a&gt;，状态是关闭的，作者 &amp;#64;frnkvieira 说 &amp;#64;zzeric 已经修复，他已合入最新版，下面又有人要求打开这个 issues，说经过测试依然存在。&lt;/p&gt;
&lt;p&gt;&amp;#64;zzeric_ 的解决办法是升级到 python 3.7.0，我个人认为这并非一个好的办法。
&amp;#64;danieldaeschle_ 的解决办法是 &lt;a class="reference external" href="https://github.com/vibora-io/vibora/pull/157"&gt;vibora-pull-157&lt;/a&gt; ，不过作者并未接受。&lt;/p&gt;
&lt;p&gt;我暂时采用了 &lt;a class="reference external" href="https://github.com/danieldaeschle"&gt;danieldaeschle&lt;/a&gt; 的方法修改，再次运行，提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OSError: [Errno 112] Address already in use
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过，此时浏览器打开 &lt;a class="reference external" href="http://localhost:8000"&gt;http://localhost:8000&lt;/a&gt; 已经可以正常显示:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{'hello': 'world'}
&lt;/pre&gt;
&lt;p&gt;本文的第三部分，剩下的就是作个总结。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="windows-linux"&gt;
&lt;h2&gt;Windows 下用 Linux 的途径&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;虚拟机&lt;/dt&gt;
&lt;dd&gt;虚拟机是在物理宿主机上虚拟一台机器，再将 Linux 安装进去。Windows 平台的虚拟机软件也有不少选择，而且微软也内置了一种虚拟机 Hyper-V&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;类Linux / POSIX API 方案&lt;/dt&gt;
&lt;dd&gt;这类方案是在 Windows 核心上实现一种 类Linux / POSIX 标准的中间翻译层，要么对接到 Windows 原生动态链接库，要么对接到自带的库。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Windows Subsystem for Linux&lt;/dt&gt;
&lt;dd&gt;这是基于市场博弈和市场的发展，微软官方基于 Hyper-V 给出了一个解决方案，这个方案可以从微软商店中下载 Linux，目前官方支持 5 种比较常见的发行版。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是我的一些理解&lt;/p&gt;
&lt;div class="section" id="virtualbox"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.virtualbox.org/"&gt;VirtualBox&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在普通需求上，这是我最愿意使用的一种便携方案，比如国内银行的 usb key 只支持 Windows 时，使用虚拟机也是挺好的，适合个人。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vmware"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.vmware.com/"&gt;VMWare&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;他们具备成熟的生产环境商业方案，但其实更适合开发环境和测试环境构建一套安全、灵活、可扩展的系统环境。但现在虚拟化的趋势中有所过气，XEN 算是 Linux 上对标的方案。但他们家显卡驱动实在不行。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hyper-v"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v"&gt;Hyper-V&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在虚拟微软自家系统旧版本时，这个是最佳方案，一些微软自家新技术，也是以此虚拟机发布的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="docker"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.docker.com/"&gt;Docker&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它不是虚拟机，但是目前很不错的容器虚拟化技术，但它需要 Widnows Pro 版本以上，且不能与 VirtualBox 和 VMWare 及一些 Android 模拟器共存。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cygwin-mingw"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://www.cygwin.com/"&gt;Cygwin&lt;/a&gt; &amp;amp; &lt;a class="reference external" href="http://www.mingw.org/"&gt;MinGW&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Cygwin 通过动态链接库 cygwin1.dll，提供一个 POSIX API 子集，编译出 Linux 下的程序通过这个库对接 Windows 底层动态链接库。&lt;/p&gt;
&lt;p&gt;MinGW 是 GCC 在 Windows 的实现，通过编译器，把诸如 Linux 系统调用 如 fork 翻译成 Windows API 如 CreateProcess 这样。这种没有引入运行时的中间层，会比 Cygwin 更紧凑。&lt;/p&gt;
&lt;p&gt;通俗的说 Cygwin 属于运行时适配，MinGW 属于编译时转化，从技术纯粹来说，我更喜欢 MinGW，但对于绝大多数小的程序，Cygwin 虽然多了中间层，但可移植性比 MinGW 强。&lt;/p&gt;
&lt;p&gt;跨平台属于商业鸿沟，技术上也是一个复杂问题，之所以跨平台这个问题这么难，是因为平台差异导致的，比如可执行文件格式差异，Windows 是 PE 文件，Linux 是 ELF 文件，于是需要分别编译。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="msys-msys2"&gt;
&lt;h3&gt;&lt;a class="reference external" href="http://www.mingw.org/wiki/MSYS"&gt;MSYS&lt;/a&gt; &amp;amp; &lt;a class="reference external" href="http://www.msys2.org/"&gt;MSYS2&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;MSYS 这个项目，由多年前的 MinGW 团队开始，并成为 Cygwin 的一个分支，一个从来没有跟上 Cygwin 发展的分支，目前已不活跃，如果有选择，请选择 MSYS2。&lt;/p&gt;
&lt;p&gt;MSYS2 是 MSYS 的一个升级版，它集成了 pacman 和 &lt;a class="reference external" href="http://mingw-w64.org/"&gt;Mingw-w64&lt;/a&gt; 的 Cygwin 升级版, 提供了 Bash 等 Linux 环境、版本控制软件（Git/hg）和 MinGW-w64 工具链。
它是由 mingw-builds 团队（也是MinGW-w64工具链的官方包装商）的 Alexey Pavlov 开发的一个项目，密切更新到最新的 Cygwin，使其不会过时。&lt;/p&gt;
&lt;p&gt;MSYS2 不完全是基于 MinGW 的，至少其原生工具都是链接到自带的一套特定版本的 Cygwin DLL ，基本上只是用 libalpm 管理 MSYS2、MinGW-w64 和 MinGW 三个不同子系统的软件包。
Cygwin、MSYS 和 Git for Windows（前称 msysgit）里各有一套 Cygwin DLL 而且互不兼容，而 MinGW 那两个子系统都不需要链接到任何版本的 Cygwin DLL。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="windows-subsystem-for-linux"&gt;
&lt;h3&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/windows/wsl/about"&gt;Windows Subsystem for Linux&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下载安装都很容易，可以在 Windows Store 下载，其中的坑在评论中都已解决。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;用户可以使用 Linux 常见工具：grep, sed, awk, Bash, vim, emacs, tmux 等&lt;/li&gt;
&lt;li&gt;可以支持很多运行时：Javascript/node.js, Ruby, Python, C/C++, C# &amp;amp; F#, Rust, Go&lt;/li&gt;
&lt;li&gt;以及很多 Linux 的服务端软件：sshd, MySQL, Apache, lighttpd&lt;/li&gt;
&lt;li&gt;还可以使用包管理器，如 apt-get 等&lt;/li&gt;
&lt;li&gt;支持 Linux 和 Windows 程序的双向调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我有安装过 WSL Ubuntu，其性能不高，图形包等并未尝试，相比虚拟机，觉得目前不具太大意义。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说，本文讲了 Windows 下用 Linux 的两个例子，再总结了一些 Windows 下 使用 Linux 的方法，整体内容很多。&lt;/p&gt;
&lt;p&gt;最后来说，一个更好的方案可能是一台高配 macOS 运行 Parallels Desktop，再其中运行 Windows ;)&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Windows"></category><category term="Linux"></category><category term="Jekyll"></category><category term="Ruby"></category><category term="MSYS2"></category><category term="Vibora"></category><category term="Cygwin"></category><category term="MinGW"></category><category term="Virtualpc"></category><category term="VMWare"></category><category term="Docker"></category><category term="MSYS"></category><category term="msysgit"></category></entry><entry><title>Windows 下 Node 的路径配置</title><link href="https://kaffa.im/config-nodejs-path-in-windows.html" rel="alternate"></link><published>2018-08-06T22:00:00+08:00</published><updated>2018-08-06T22:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-08-06:/config-nodejs-path-in-windows.html</id><summary type="html">&lt;p class="first last"&gt;本文描述 Windows 下 nodejs 的路径配置问题，也涉及 Windows 路径的说明&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="windows-nodejs"&gt;
&lt;h2&gt;在 Windows 下安装 nodejs&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;浏览器打开 nodejs 官方网站 &lt;a class="reference external" href="https://nodejs.org/"&gt;https://nodejs.org/&lt;/a&gt;，选择 LTS 或者 Current 版本。&lt;/li&gt;
&lt;li&gt;用下载软件（如迅雷）下载目前的最新版 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;https://nodejs.org/dist/v10.8.0/node-v10.8.0-x64.msi&lt;/span&gt;&lt;/tt&gt;，下载到本地后，双击安装。&lt;/li&gt;
&lt;li&gt;个人推荐将运行时安装在根路径下，因为当需要进入运行时目录查看时，每次会比进入 Program Files 少进一层，这样可以节省时间。我的安装目录是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\nodejs&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;在 Windows 下配置 nodejs&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;至此 nodejs 就已经安装好了，其中 npm 是 nodejs 的包管理器，此时已经在 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\nodejs\node_modules\npm&lt;/span&gt;&lt;/tt&gt; 之下&lt;/li&gt;
&lt;li&gt;然后在 Windows 下 nodejs 还需要配置两个重要的路径：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个是 node_global，这个目录用来放全局安装命令 &lt;tt class="docutils literal"&gt;npm install [PACKAGE_NAME] &lt;span class="pre"&gt;-g&lt;/span&gt;&lt;/tt&gt; 安装的包，通常将很多基础的共用包可以安装到这个目录，例如 nw&lt;/p&gt;
&lt;p&gt;一个是 node_cache，这个目录是 node 缓存&lt;/p&gt;
&lt;p&gt;我们用 &lt;tt class="docutils literal"&gt;npm install [PACKAGE_NAME]&lt;/tt&gt; 命令安装的内容，会安装在每个目录下，这就是 node 来管理依赖的方式。&lt;/p&gt;
&lt;p&gt;运行下面命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C:\&amp;gt;cd nodejs
C:\nodejs&amp;gt;mkdir node_global
C:\nodejs&amp;gt;mkdir node_cache
C:\nodejs&amp;gt;npm config set prefix &amp;quot;C:\nodejs\node_global&amp;quot;
C:\nodejs&amp;gt;npm config set cache &amp;quot;C:\nodejs\node_cache&amp;quot;
&lt;/pre&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;配置环境变量 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;NODE_PATH=C:\nodejs\&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;在 PATH 中 加入 &lt;tt class="docutils literal"&gt;%NODE_PATH%&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;%NODE_PATH%\node_global&lt;/span&gt;&lt;/tt&gt;，顺便推荐使用 &lt;a class="reference external" href="https://www.rapidee.com"&gt;Rapid Environment Editor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;至此，Windows 下的 nodejs 配置完毕&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;补充说明&lt;/h2&gt;
&lt;p&gt;本文推荐的路径是最简单的方法，下面对 Windows 路径本身的机制加以说明:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1. 应用数据全局目录：C:\ProgramData\
2. 应用数据用户目录：C:\Users\USER_NAME\AppData\Roaming\
3. 用户根目录：C:\Users\USER_NAME\
4. 64位程序目录：C:\Program Files\，非管理员权限不可写
5. 32位程序目录：C:\Program Files (x86)\，非管理员权限不可写
&lt;/pre&gt;
&lt;p&gt;如果 npm 出现警告 &lt;tt class="docutils literal"&gt;Missing write access&lt;/tt&gt;，接着出现错误 &lt;tt class="docutils literal"&gt;npm ERR! code ENOENT&lt;/tt&gt;，则和上述权限有关，这里的 ENOENT 是 Error NO ENTry 的意思:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pm WARN checkPermissions Missing write access
...
npm ERR! code ENOENT
npm ERR! errno -2
npm ERR! syscall access
npm ERR! enoent ENOENT: no such file or directory, access '/usr/local/lib/node_modules/webpack/node_modules/[XXX]'
npm ERR! enoent This is related to npm not being able to find a file.
npm ERR! enoent
&lt;/pre&gt;
&lt;p&gt;如果忘记将 nodejs 放入PATH，那么可能会出现以下错误提示，因为程序调用 node 时， Windows 找不到 node.exe 或 node.cmd 或 node.bat:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
'node' 不是内部或外部命令，也不是可运行的程序或批处理文件
&lt;/pre&gt;
&lt;p&gt;另外，当然也可以参考官方文档 &lt;a class="reference external" href="https://docs.npmjs.com/files/folders"&gt;npm-folders&lt;/a&gt;，但可能有更新不及时，node 社区还年轻且贡献者有很多个人，有时并不太照顾 Windows 平台，这点不比 python 社区发展了那么久，且那么多机构贡献者。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Node"></category><category term="Node.js"></category><category term="Windows"></category><category term="Path"></category></entry><entry><title>关于 NW.js 与 Electron 的技术选择</title><link href="https://kaffa.im/nwjs-and-electron-how-to-choose.html" rel="alternate"></link><published>2018-08-06T12:00:00+08:00</published><updated>2018-08-06T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-08-06:/nwjs-and-electron-how-to-choose.html</id><summary type="html">&lt;p class="first last"&gt;本文顺便写上 NW.js 与 Electron 的技术选择和一些无关的文字&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;技术选择&lt;/h2&gt;
&lt;p&gt;这么多年，我很少写技术博文，通常记录的目的都是归于实用，即遇到一个问题，然后给予解决。原则是，不从问题作无止的延伸，但给予一个清晰的解答。之所以有此原则，是因实用主义，因生命有限，无法耗时在细节上，细节是熵递增，与生命的目的刚好相反。&lt;/p&gt;
&lt;p&gt;那么我们从怎样的方法论去讨论技术选择问题呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;NW.js 与 Electron&lt;/h2&gt;
&lt;p&gt;在两者的选择之间：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;从目前来看，选择 Electron&lt;/li&gt;
&lt;li&gt;从目前来看，根据场景，大多时候选择 Electron 即可，特殊情况，选择合适的即可。&lt;/li&gt;
&lt;li&gt;而 Electron 和 NW.js，当你充分了解它们时，它们有区别？又或则不能选其他？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于两种跨平台技术的选择，说完了？&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;选择的法门&lt;/h2&gt;
&lt;p&gt;因人的思维本质，因那个创造者，那个“神”、“神性”、“中心”而具共性。“法门”的表述可能不同，但内核相似，主要是人的思维和意识相似共性。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;初遇技术选择的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;儿时父母初教：“你记下，当人对你说‘你好’时，你就答一句‘你好’”，这叫，习得的问题解决方案。&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;反复遇到相同技术选择的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生活中，遇到很多人对你说“你好”，回答开始可能是“你好”，但后面也会根据具体情境给不同回答。&lt;/p&gt;
&lt;p&gt;例如，对陌生人回答“你是谁？”，对密友回答“你好个P，你脑子坏了！”，对客户答“你好你好你好！”&lt;/p&gt;
&lt;p&gt;你会发现，进入场景，戴上身份后，你好的回答并不只是你好，会根据不同而进行“恰当”回答了。&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;无数技术选择后，眼里不再有问题时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你会发现一句淡定的回答“你好”，其实还是儿时那句“你好”，竟是所有“你好”的回答。&lt;/p&gt;
&lt;p&gt;你也许听过：&lt;/p&gt;
&lt;blockquote&gt;
第一重境界：昨夜西风凋碧树。独上高楼，望尽天涯路；
第二重境界：衣带渐宽终不悔，为伊消得人憔悴；
第三重境界：众里寻他千百度，蓦然回首，那人却在灯火阑珊处。&lt;/blockquote&gt;
&lt;p&gt;也许还听过：&lt;/p&gt;
&lt;blockquote&gt;
看山是山，看山不是山，看山还是山。&lt;/blockquote&gt;
&lt;p&gt;也许还听过：&lt;/p&gt;
&lt;blockquote&gt;
非有，非无，非有非无。&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;心理学&lt;/h2&gt;
&lt;p&gt;人会从各个视角对世界给予解释，其实是人的大脑生物机制本身决定的，动物脑以及灵性脑，感性与理性，象与骑象人的对话，你的骑象人总在回答（大多是解释）你的大象，而一旁的观察者很关键。&lt;/p&gt;
&lt;p&gt;此处，象即1，骑象人即2，观察者即3；象即问题的直接答案，骑象人即问题的周全答案，而观察者眼里并没有问和答，它归于沉默。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;其实已经说完了&lt;/h2&gt;
&lt;p&gt;四维生物，二不行，但三基本就够了。其实已经说完了。&lt;/p&gt;
&lt;p&gt;“人往往需要说很多话，然后才能归入潜默。” 是有此篇。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Psychology"></category><category term="Philosophy"></category><category term="NW.js"></category><category term="Electron"></category></entry><entry><title>关于文本二维码这件小事</title><link href="https://kaffa.im/a-story-about-text-qrcode.html" rel="alternate"></link><published>2018-07-27T12:00:00+08:00</published><updated>2018-07-27T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-07-27:/a-story-about-text-qrcode.html</id><summary type="html">&lt;p class="first last"&gt;本文随意聊聊文本二维码&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id2"&gt;
&lt;h2&gt;文本二维码&lt;/h2&gt;
&lt;p&gt;简单讲，二维码是一个算法，可以把信息编码为0和1，也就是白和黑，也就是常见的二维码。大多情况下，二维码用一个方形的图片表达，可以跨各种介质传播。&lt;/p&gt;
&lt;p&gt;但由于一个很特殊的软件，我们有将二维码从远程机器传递到本地文本终端的需求。因此，引出了文本二维码这个议题:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
█ ▄▄▄▄▄ █▀▄█▀ █▀ █▀█▄▀█ ▄▄▄▄▄ █
█ █   █ █▄   ▄▀ ▀▄▄█▀▀█ █   █ █
█ █▄▄▄█ █ ▀█▀█▄█▀   ▀▀█ █▄▄▄█ █
█▄▄▄▄▄▄▄█ ▀▄█ █ ▀▄▀▄▀ █▄▄▄▄▄▄▄█
█▄▄█▄▀▀▄▄▀█ ▀█▀ ▀ ▀█▄█▀ ▄▄▀▄▄▀█
█ ▀▀▀▄▀▄ █▄▄██ ██ ▄ ▄▄  ▄ ▄  ██
█▄ ▄███▄███▀▀ █▀▀█▄█  ▀▄██▄█▄▄█
██▄▄ ▄█▄ ▄▀██ ▀▀█ ▀▀▀▄ ▀██ ▄ ▄█
█▄▀▀▄▄ ▄▄▄ ▀▄██▄█▄ ██▄▄▀▀█▀█▄▀█
█▄█▄▀▀ ▄▀▄█▄▀██▀█▄▀▀█▄▄▄▄▀██  █
█▄██▄▄▄▄█  ▀  ▄▀█ █▄▄ ▄▄▄ █ ▀▀█
█ ▄▄▄▄▄ █▄█▄   █▀▀▄▀█ █▄█ ▀▀ ▀█
█ █   █ █▀▄▄ █▀▄█▀▄█▀▄▄   ▀▀▀██
█ █▄▄▄█ █▀ █ █▄▄█▀ █▀ ██▀▄▄▄▀▄█
█▄▄▄▄▄▄▄█▄█▄█▄▄█▄█▄▄█▄▄█▄█▄█▄██
&lt;/pre&gt;
&lt;p&gt;上述即一个文本二维码，通常两行一列编码为一个半角字符，这个二维码的显示需要两个前提：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;等宽字符，例如 Lucida Console&lt;/li&gt;
&lt;li&gt;行间距尽量小，让整体显示为正方形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，能否扫描出结果，也取决于扫描时的容差。&lt;/p&gt;
&lt;p&gt;在 Windows 平台，如果终端控制台中出现文本二维码散乱情况，请调整控制台字体为等宽字体，或者打开记事本，字体选择为：Lucida Console 5号字，再进行全选，即可显示出可扫描的二维码。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="QRCode"></category><category term="Text QRCode"></category></entry><entry><title>在 Windows 10 下安装 Wechaty</title><link href="https://kaffa.im/wechaty-installation-on-windows-10.html" rel="alternate"></link><published>2018-07-24T12:00:00+08:00</published><updated>2018-07-24T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-07-24:/wechaty-installation-on-windows-10.html</id><summary type="html">&lt;p class="first last"&gt;本文描述 Windows 下安装 Wechaty 的细节&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/Chatie/wechaty"&gt;Wechaty&lt;/a&gt; 是一个对话机器人软件开发包，它可以帮你用 6 行 JavaScript 代码实现一个微信个人账号。由于使用 node 技术，它支持 Linux、Windows、macOS 平台和 Docker 容器。它的安装过程和其它 node 包类似，首先 &lt;tt class="docutils literal"&gt;git clone&lt;/tt&gt; 源代码，再使用 node 的 npm 命令 &lt;tt class="docutils literal"&gt;npm install &amp;amp; npm start&lt;/tt&gt; 实现开箱即用，同时官方也提供了入门案例：&lt;a class="reference external" href="https://github.com/Chatie/wechaty-getting-started"&gt;Wechaty getting started&lt;/a&gt;。而在国内，实际安装过程中可能会因某些软件依赖的原因遇到问题，本文记录了安装过程中可能会出现的错误及解决办法，下面描述详细的步骤和说明：&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://github.com/Chatie/wechaty"&gt;Wechaty&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;项目地址&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://github.com/Chatie/wechaty-getting-started"&gt;Wechaty Getting Started&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Wechaty 起步&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://chatie.io/wechaty/"&gt;Wechaty Documents&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Wechaty 文档&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://github.com/Chatie/wechaty/wiki/Puppet"&gt;Puppet&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;一个包含了机器人对话逻辑的抽象类，是 Wechaty 技术架构的一部分。继承实现 Puppet 抽象类（协议）的组件，即可实现更广泛的与联系人、消息/一对一对话、群组/聊天室/多对多对话等相关逻辑。Puppet 的中文是木偶，用在这里相当传神。&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://www.npmjs.com/package/node-gyp"&gt;node-gyp&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;基于 gyp 编写的用来编译 node 本地扩展模块的 node 包，而 gpy 是 Chromium 项目上用于实现跨平台编译的工具。
安装文档：&lt;a class="reference external" href="https://github.com/nodejs/node-gyp#installation"&gt;https://github.com/nodejs/node-gyp#installation&lt;/a&gt;&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://www.npmjs.com/package/windows-build-tools"&gt;windows-build-tools&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;node 包装的 Windows 平台的编译工具
安装文档：&lt;a class="reference external" href="https://github.com/felixrieseberg/windows-build-tools"&gt;https://github.com/felixrieseberg/windows-build-tools&lt;/a&gt;&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://www.npmjs.com/package/node-expat"&gt;node-expat&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;基于 &lt;a class="reference external" href="https://libexpat.github.io/"&gt;libexpat&lt;/a&gt; 的用来处理 XML 的 node 包，libexpat 是一个号称最快的 XML 解析库，纯 C 语言编写。Wechaty 使用它解析基于 XML 的通讯。
安装文档：&lt;a class="reference external" href="https://www.npmjs.com/package/node-expat"&gt;https://www.npmjs.com/package/node-expat&lt;/a&gt;&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://www.python.org/downloads/"&gt;Python 2.7&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;一门愈久弥新的语言，node-gyp 的依赖 Python 2.7 实现跨平台编译&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://github.com/GoogleChrome/puppeteer"&gt;puppeteer&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;可编程的 Google Chrome， Google Chrome 团队官方出品。&lt;/dd&gt;
&lt;dt&gt;&lt;a class="reference external" href="https://www.chromium.org/"&gt;Chromium&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;puppeteer 依赖一个特定的 Chromium 版本，Chrome 就是 开源 Chromium + Google 开发的闭源的扩展包。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3&gt;安装步骤&lt;/h3&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;下载 Wechaty 源代码&lt;/li&gt;
&lt;li&gt;安装依赖，配置&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;npm install &amp;amp; npm start&lt;/tt&gt; 启动&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;详细步骤&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;下载 Wechaty 源代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先我们建立源代码目录，本文使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;D:\code&lt;/span&gt;&lt;/tt&gt;。如果你使用了其他目录，在后文中作相应的替换即可。
让我们从入门项目开始，运行以下命令下载，并进入项目目录:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
git clone https://github.com/lijiarui/wechaty-getting-started.git
cd wechaty-getting-started
&lt;/pre&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先安装 &lt;strong&gt;node-v10.x.x&lt;/strong&gt;。在 Windows 下，推荐使用官方提供的安装包，截至本文最新 64 位系统安装包是：&lt;a class="reference external" href="https://nodejs.org/dist/v10.7.0/node-v10.7.0-x64.msi"&gt;https://nodejs.org/dist/v10.7.0/node-v10.7.0-x64.msi&lt;/a&gt;，如果网速不够，建议使用迅雷下载。&lt;/p&gt;
&lt;p&gt;除了 node-v10 ，Wechaty 也依赖其它软件，而由于众所周知的网络原因，安装它们并不会太顺利。&lt;/p&gt;
&lt;p&gt;此时，如果运行 &lt;tt class="docutils literal"&gt;npm install &amp;amp; npm start&lt;/tt&gt;，会报以下错误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Microsoft Windows [版本 10.0.16299.492]
(c) 2017 Microsoft Corporation。保留所有权利。


D:\code&amp;gt;cd wechaty-getting-started

D:\code\wechaty-getting-started&amp;gt;npm install
npm notice created a lockfile as package-lock.json. You should commit this file.
added 134 packages from 94 contributors and audited 324 packages in 22.581s
found 0 vulnerabilities


D:\code\wechaty-getting-started&amp;gt;npm start

&amp;gt; wechaty-getting-started&amp;#64;0.1.0 start D:\code\wechaty-getting-started
&amp;gt; node examples/starter-bot.js

01:59:34 INFO Wechaty &amp;lt;default&amp;gt; start() v0.18.5 is starting...
01:59:34 INFO Wechaty initPuppet() using puppet: default
01:59:34 INFO PuppetConfig installPuppet(wechaty-puppet-puppeteer&amp;#64;^0.4.2) please wait ...
npm:
&amp;gt; node-expat&amp;#64;2.3.16 install D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat
&amp;gt; node-gyp rebuild


npm:
D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat&amp;gt;if not defined npm_config_node_gyp (node &amp;quot;D:\Program Files\nodejs\node_modules\npm\node_modules\npm-lifecycle\node-gyp-bin\\..\..\node_modules\node-gyp\bin\node-gyp.js&amp;quot; rebuild )  else (node &amp;quot;D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\bin\node-gyp.js&amp;quot; rebuild )

npm: gyp
npm:  ERR! configure error
gyp ERR! stack Error: Can't find Python executable &amp;quot;C:\Python36\python.EXE&amp;quot;, you can set the PYTHON env variable.
gyp ERR! stack     at PythonFinder.failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:483:19)
gyp ERR! stack     at PythonFinder.&amp;lt;anonymous&amp;gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:508:16)
gyp ERR! stack     at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills.js:284:29
gyp ERR! stack     at FSReqWrap.oncomplete (fs.js:158:21)
gyp ERR! System Windows_NT 10.0.16299

npm: gyp ERR! command &amp;quot;D:\\Program Files\\nodejs\\node.exe&amp;quot; &amp;quot;D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&amp;quot; &amp;quot;rebuild&amp;quot;
gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat
gyp ERR! node -v v10.7.0
gyp ERR! node-gyp -v v3.6.2
gyp ERR! not ok

npm: npm WARN
npm:  wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of brolog&amp;#64;^1.6.5 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of file-box&amp;#64;^0.8.22 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of hot-import&amp;#64;^0.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of lru-cache&amp;#64;^4.1.3 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of qr-image&amp;#64;^3.2.0 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of promise-retry&amp;#64;^1.1.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rxjs&amp;#64;^6.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rx-queue&amp;#64;^0.4.26 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of state-switch&amp;#64;^0.6.2 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of watchdog&amp;#64;^0.8.10 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of wechaty-puppet&amp;#64;^0.6.4 but none is installed. You must install peer dependencies yourself.


npm: npm ERR!
npm:  code ELIFECYCLE
npm ERR! errno 1
npm ERR! node-expat&amp;#64;2.3.16 install: `node-gyp rebuild`
npm ERR! Exit status 1

npm: npm ERR!
npm ERR! Failed at the node-expat&amp;#64;2.3.16 install script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm:
npm
npm:  ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug.log

01:59:53 ERR PupptConfig puppetResolver(default) install fail: Command failed: npm install wechaty-puppet-puppeteer&amp;#64;^0.4.2
gyp ERR! configure error
gyp ERR! stack Error: Can't find Python executable &amp;quot;C:\Python36\python.EXE&amp;quot;, you can set the PYTHON env variable.
gyp ERR! stack     at PythonFinder.failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:483:19)
gyp ERR! stack     at PythonFinder.&amp;lt;anonymous&amp;gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:508:16)
gyp ERR! stack     at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills.js:284:29
gyp ERR! stack     at FSReqWrap.oncomplete (fs.js:158:21)
gyp ERR! System Windows_NT 10.0.16299
gyp ERR! command &amp;quot;D:\\Program Files\\nodejs\\node.exe&amp;quot; &amp;quot;D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&amp;quot; &amp;quot;rebuild&amp;quot;
gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat
gyp ERR! node -v v10.7.0
gyp ERR! node-gyp -v v3.6.2
gyp ERR! not ok
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of brolog&amp;#64;^1.6.5 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of file-box&amp;#64;^0.8.22 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of hot-import&amp;#64;^0.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of lru-cache&amp;#64;^4.1.3 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of qr-image&amp;#64;^3.2.0 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of promise-retry&amp;#64;^1.1.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rxjs&amp;#64;^6.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rx-queue&amp;#64;^0.4.26 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of state-switch&amp;#64;^0.6.2 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of watchdog&amp;#64;^0.8.10 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of wechaty-puppet&amp;#64;^0.6.4 but none is installed. You must install peer dependencies yourself.

npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! node-expat&amp;#64;2.3.16 install: `node-gyp rebuild`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the node-expat&amp;#64;2.3.16 install script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug.log

{ Error: Command failed: npm install wechaty-puppet-puppeteer&amp;#64;^0.4.2
gyp ERR! configure error
gyp ERR! stack Error: Can't find Python executable &amp;quot;C:\Python36\python.EXE&amp;quot;, you can set the PYTHON env variable.
gyp ERR! stack     at PythonFinder.failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:483:19)
gyp ERR! stack     at PythonFinder.&amp;lt;anonymous&amp;gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:508:16)
gyp ERR! stack     at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills.js:284:29
gyp ERR! stack     at FSReqWrap.oncomplete (fs.js:158:21)
gyp ERR! System Windows_NT 10.0.16299
gyp ERR! command &amp;quot;D:\\Program Files\\nodejs\\node.exe&amp;quot; &amp;quot;D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&amp;quot; &amp;quot;rebuild&amp;quot;
gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat
gyp ERR! node -v v10.7.0
gyp ERR! node-gyp -v v3.6.2
gyp ERR! not ok
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of brolog&amp;#64;^1.6.5 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of file-box&amp;#64;^0.8.22 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of hot-import&amp;#64;^0.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of lru-cache&amp;#64;^4.1.3 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of qr-image&amp;#64;^3.2.0 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of promise-retry&amp;#64;^1.1.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rxjs&amp;#64;^6.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rx-queue&amp;#64;^0.4.26 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of state-switch&amp;#64;^0.6.2 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of watchdog&amp;#64;^0.8.10 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of wechaty-puppet&amp;#64;^0.6.4 but none is installed. You must install peer dependencies yourself.

npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! node-expat&amp;#64;2.3.16 install: `node-gyp rebuild`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the node-expat&amp;#64;2.3.16 install script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug.log

    at ChildProcess.exithandler (child_process.js:291:12)
    at ChildProcess.emit (events.js:182:13)
    at ChildProcess.EventEmitter.emit (domain.js:442:20)
    at maybeClose (internal/child_process.js:961:16)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:248:5)
killed: false,
code: 1,
signal: null,
cmd: 'npm install wechaty-puppet-puppeteer&amp;#64;^0.4.2 ' }
01:59:53 ERR Wechaty start() exception: Command failed: npm install wechaty-puppet-puppeteer&amp;#64;^0.4.2
gyp ERR! configure error
gyp ERR! stack Error: Can't find Python executable &amp;quot;C:\Python36\python.EXE&amp;quot;, you can set the PYTHON env variable.
gyp ERR! stack     at PythonFinder.failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:483:19)
gyp ERR! stack     at PythonFinder.&amp;lt;anonymous&amp;gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:508:16)
gyp ERR! stack     at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills.js:284:29
gyp ERR! stack     at FSReqWrap.oncomplete (fs.js:158:21)
gyp ERR! System Windows_NT 10.0.16299
gyp ERR! command &amp;quot;D:\\Program Files\\nodejs\\node.exe&amp;quot; &amp;quot;D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&amp;quot; &amp;quot;rebuild&amp;quot;
gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat
gyp ERR! node -v v10.7.0
gyp ERR! node-gyp -v v3.6.2
gyp ERR! not ok
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of brolog&amp;#64;^1.6.5 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of file-box&amp;#64;^0.8.22 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of hot-import&amp;#64;^0.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of lru-cache&amp;#64;^4.1.3 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of qr-image&amp;#64;^3.2.0 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of promise-retry&amp;#64;^1.1.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rxjs&amp;#64;^6.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rx-queue&amp;#64;^0.4.26 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of state-switch&amp;#64;^0.6.2 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of watchdog&amp;#64;^0.8.10 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of wechaty-puppet&amp;#64;^0.6.4 but none is installed. You must install peer dependencies yourself.

npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! node-expat&amp;#64;2.3.16 install: `node-gyp rebuild`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the node-expat&amp;#64;2.3.16 install script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug.log

{ Error: Command failed: npm install wechaty-puppet-puppeteer&amp;#64;^0.4.2
gyp ERR! configure error
gyp ERR! stack Error: Can't find Python executable &amp;quot;C:\Python36\python.EXE&amp;quot;, you can set the PYTHON env variable.
gyp ERR! stack     at PythonFinder.failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:483:19)
gyp ERR! stack     at PythonFinder.&amp;lt;anonymous&amp;gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure.js:508:16)
gyp ERR! stack     at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills.js:284:29
gyp ERR! stack     at FSReqWrap.oncomplete (fs.js:158:21)
gyp ERR! System Windows_NT 10.0.16299
gyp ERR! command &amp;quot;D:\\Program Files\\nodejs\\node.exe&amp;quot; &amp;quot;D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js&amp;quot; &amp;quot;rebuild&amp;quot;
gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat
gyp ERR! node -v v10.7.0
gyp ERR! node-gyp -v v3.6.2
gyp ERR! not ok
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of brolog&amp;#64;^1.6.5 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of file-box&amp;#64;^0.8.22 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of hot-import&amp;#64;^0.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of lru-cache&amp;#64;^4.1.3 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of qr-image&amp;#64;^3.2.0 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of promise-retry&amp;#64;^1.1.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rxjs&amp;#64;^6.2.1 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of rx-queue&amp;#64;^0.4.26 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of state-switch&amp;#64;^0.6.2 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of watchdog&amp;#64;^0.8.10 but none is installed. You must install peer dependencies yourself.
npm WARN wechaty-puppet-puppeteer&amp;#64;0.4.2 requires a peer of wechaty-puppet&amp;#64;^0.6.4 but none is installed. You must install peer dependencies yourself.

npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! node-expat&amp;#64;2.3.16 install: `node-gyp rebuild`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the node-expat&amp;#64;2.3.16 install script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug.log

    at ChildProcess.exithandler (child_process.js:291:12)
    at ChildProcess.emit (events.js:182:13)
    at ChildProcess.EventEmitter.emit (domain.js:442:20)
    at maybeClose (internal/child_process.js:961:16)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:248:5)
killed: false,
code: 1,
signal: null,
cmd: 'npm install wechaty-puppet-puppeteer&amp;#64;^0.4.2 ' }

D:\code\wechaty-getting-started&amp;gt;
&lt;/pre&gt;
&lt;p&gt;通过阅读上述日志，分析依赖关系如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
wechaty-puppet-puppeteer --&amp;gt; node-expat --&amp;gt; node-gyp --&amp;gt; gyp --&amp;gt; Python 2.7 &amp;amp; Windows Build Tools
&lt;/pre&gt;
&lt;p&gt;所以，接下来要做的就是一一从依赖的最底层安装&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;安装 &lt;a class="reference external" href="https://www.python.org/downloads/"&gt;Python 2.7&lt;/a&gt; 至 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\Python27\python.exe&lt;/span&gt;&lt;/tt&gt;，设置环境变量 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;PYTHON=C:\Python27\python.exe&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意 node-gyp 并不支持 Python 3.x，如果你安装了 Python 3.x，错误日志如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Can't find Python executable &amp;quot;C:\Python36\python.EXE&amp;quot;, you can set the PYTHON env variable.
&lt;/pre&gt;
&lt;p&gt;你可能会疑惑这个本来存在的 Python 3 路径，个人认为这个不准确错误提示可以算入 npm 包的 Bug&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;安装 &lt;a class="reference external" href="https://www.npmjs.com/package/windows-build-tools"&gt;windows-build-tools&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考 windows-build-tools 官方文档，有以下两种方式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1.Visual C++ Build Tools
2.Visual Studio 2017 / Visual Studio 2015
&lt;/pre&gt;
&lt;p&gt;我这里由于已经安装 Visual Studio 2017 社区版，所以没有尝试其他选项。这里的关键是需要一个 VC++ 编译器来编译 Windows 本地程序。选项1在微软官方地址已失效，不容易找到，npm 官方推荐了安装 Visual Studio 2015。
安装结束后，可以使用 &lt;tt class="docutils literal"&gt;npm install &lt;span class="pre"&gt;node-expat&lt;/span&gt;&lt;/tt&gt; 验证上述安装配置是否成功&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;安装 &lt;a class="reference external" href="https://github.com/GoogleChrome/puppeteer"&gt;puppeteer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于网络原因，puppeteer 依赖的 &lt;a class="reference external" href="https://www.chromium.org/"&gt;Chromium&lt;/a&gt; 并不能顺利安装。此时，我们可以借助一个阿里巴巴公司提供的 &lt;a class="reference external" href="https://npm.taobao.org/"&gt;cnpm&lt;/a&gt; 特色工具安装:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm install puppeteer
&lt;/pre&gt;
&lt;p&gt;如果你遇到 &lt;tt class="docutils literal"&gt;Chromium revision is not downloaded.&lt;/tt&gt; 时，在解决办法中看到的设置 PUPPETEER_SKIP_CHROMIUM_DOWNLOAD 其实是一个误导，
这个选项并不能帮助你安装 puppeteer，而是让你在更新时不必每次都下载 Chromium 二进制。&lt;/p&gt;
&lt;p&gt;PS: 这里还有一个手动安装办法，但不推荐：可以手动下载 chromium 安装包，放在 /node_modules/puppeteer/.local-chromium/ 下，例如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
D:\code\wechaty-getting-started\node_modules\_puppeteer&amp;#64;1.6.0&amp;#64;puppeteer\.local-chromium\win64-571375
&lt;/pre&gt;
&lt;p&gt;这个地址在 macOS 上如下，其中的数字可能不同:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
~/node_modules/puppeteer/.local-chromium/mac-526987/chrome-mac
&lt;/pre&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;.NET Framework 4.5.1 [仅 Windows Vista / 7 需要]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 Windows Vista / 7 版本，则需要手动安装 .Net Framework&lt;/p&gt;
&lt;ol class="arabic" start="5"&gt;
&lt;li&gt;&lt;p class="first"&gt;如果使用的是 PadChat 组件的 Wechaty，且已有相应 token 则还需要设置以下几个环境变量:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
WECHATY_LOG=silly
WECHATY_PUPPET=padchat
WECHATY_PUPPET_PADCHAT_TOKEN=*YOUR-TOKEN*
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;至此，应该可以顺利运行起步项目:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
npm install &amp;amp; npm start
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;运行后，程序会在控制台窗口打开一个文本的二维码，在二维码下方是该二维码的网址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你对扫描控制台的文本二维码遇到问题，可以参考我的 &lt;a class="reference external" href="https://kaffa.im/a-story-about-text-qrcode.html"&gt;一篇关于二维码的博文&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;由于已成功启动项目，所以我并没有在 Windows 7 系统 或 32 位机上进行配置，主要问题应该差不多。
解决办法基本上一一查阅上述出现错误的软件的文档，应该可以独立解决。&lt;/p&gt;
&lt;p&gt;当然，如果你遇到了任何其他问题，也欢迎 &lt;a class="reference external" href="https://github.com/kaffa"&gt;我的Github&lt;/a&gt; 上联系我。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Wechaty"></category><category term="Node"></category><category term="Node.js"></category><category term="Open Source"></category></entry><entry><title>用 VSCode 预览 reStructureText 文件</title><link href="https://kaffa.im/preview-restructuretext-file-in-vscode.html" rel="alternate"></link><published>2018-07-18T12:30:00+08:00</published><updated>2018-07-18T12:30:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-07-18:/preview-restructuretext-file-in-vscode.html</id><summary type="html">&lt;p class="first last"&gt;本文描述用 VSCode 预览 reStructureText 文件的配置办法&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;通识&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;得益于拥抱开源，微软 VSCode 成为了最热门的 IDE，广泛用于各种场景的编程，比如编辑 reStructureText 文件。&lt;/li&gt;
&lt;li&gt;reStructureText 是 Python 官方文档的格式，属于 Sphinx 项目的一部分，Sphinx 是 Python 文档生成器。&lt;/li&gt;
&lt;li&gt;从 reStructureText 的文件格式 rst，方便转化为各种文件格式。&lt;/li&gt;
&lt;li&gt;MS Code 自带 reStructureText 插件，类似于 Markdown，安装后可以用于预览 rst 格式。&lt;/li&gt;
&lt;li&gt;可安装后并不能直接预览，还需要配置一番，于是就有了下面的部分&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;依据 reStructureText 文档，先 pip 安装 doc8 和 sphinx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;再上 MSCode 配置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// Points to the doc8 exectuable.
&amp;quot;restructuredtext.linter.executablePath&amp;quot;: &amp;quot;doc8&amp;quot;,
// Extra arguments to doc8.
&amp;quot;restructuredtext.linter.extraArgs&amp;quot;: [&amp;quot;--max-line-length 1024&amp;quot;],
// The full path of sphinx-build utility. This is an absolute path, and you can use ${workspaceRoot} to represent workspace root folder.
&amp;quot;restructuredtext.sphinxBuildPath&amp;quot;: &amp;quot;sphinx-build&amp;quot;,
// Flag to control whether text changed event triggers preview update.
&amp;quot;restructuredtext.updateOnTextChanged&amp;quot;: &amp;quot;true&amp;quot;,
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在项目根目录下运行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sphinx-quickstart
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一路回车下去，即生成了如下文件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
_build
_static
_templates
conf.py
index.rst
make.bat
Makefile
&lt;/pre&gt;
&lt;p&gt;此时可以通过 Ctrl+Shift+R 来预览了&lt;/p&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;最后提供一份快速参考 &lt;a class="reference external" href="http://www.pythondoc.com/sphinx/rest.html"&gt;sphinx-rest&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="VSCode"></category><category term="reStructureText"></category></entry><entry><title>Windows 下安装 Wechaty 的注意点(keng)</title><link href="https://kaffa.im/install-wechaty-on-windows.html" rel="alternate"></link><published>2018-07-17T12:00:00+08:00</published><updated>2018-07-17T12:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-07-17:/install-wechaty-on-windows.html</id><summary type="html">&lt;p class="first last"&gt;本文描述 Windows 下安装 Wechaty 的注意点(keng)&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文对于在 Windows 下安装 &lt;a class="reference external" href="https://github.com/Chatie/wechaty"&gt;Wechaty&lt;/a&gt; 的坑作个临时记录，但其中涉及的处理方式随着项目的升级或依赖软件的升级可能会变得不再需要。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;说明&lt;/h2&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;升级到 Node 10&lt;/dt&gt;
&lt;dd&gt;与 node 有关的问题，那可能是因为 node 没有升级到 10 以上的版本，解决办法是在 nodejs.org 官方下载 10 以上的新版本。&lt;/dd&gt;
&lt;dt&gt;安装 Python 2.7&lt;/dt&gt;
&lt;dd&gt;因为 node-gyp 依赖 Python 2.7 和 windows-build-tools，node 在安装中多采用源代码编译安装，这种的好处是跨平台。
安装好 Python 2.7 以后，需要设置环境变量
PYTHON=c:\Python27\python.exe&lt;/dd&gt;
&lt;dt&gt;文本二维码&lt;/dt&gt;
&lt;dd&gt;QR 在移动世界盛行，但 Windows 依然缺少官方提供的文本二维码方案，控制台的文本二维码支持的不好，启动二维码以后，也许格式错乱无法扫描，此时可以复制张贴到记事本中，采用合适的等宽字体进行 &lt;strong&gt;反选&lt;/strong&gt; 扫描登录。&lt;/dd&gt;
&lt;dt&gt;puppeteer&lt;/dt&gt;
&lt;dd&gt;puppeteer 是 Google Chrome？&lt;/dd&gt;
&lt;dt&gt;ts-node&lt;/dt&gt;
&lt;dd&gt;如果采用 TypeScript 版本的 Wechaty，那么 ts-node 的路径在 wechaty\node_modules\.bin\ts-node 下。&lt;/dd&gt;
&lt;dt&gt;docker Wechaty&lt;/dt&gt;
&lt;dd&gt;如果使用 docker 版本的 Wechaty，那么需要升级 Windows 到 Proffesional 版。&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;吐槽&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;一般生产推荐使用 LTS 版本的 node ，可能很多人都不会安装 node 最新版，所以此处算是一坑，官方虽有提示，但不够醒目；&lt;/li&gt;
&lt;li&gt;已经 2018 年了，大部分库都用 six 支持了 Python 2 和 3 版本，很多人都转到 Python 3.6+，对于安装时出现 Python 相关的错误时，可能不会想到是 node-gyp 依赖 Python 2.7 的原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="Wechaty"></category><category term="Node"></category><category term="Node.js"></category></entry><entry><title>升级 CentOS Linux Kernel</title><link href="https://kaffa.im/update-centos-linux-kernel.html" rel="alternate"></link><published>2018-07-06T13:00:00+08:00</published><updated>2018-07-06T13:00:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-07-06:/update-centos-linux-kernel.html</id><summary type="html">&lt;p class="first last"&gt;本文描述升级 CentOS Linux Kernel 的方法&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;升级 CentOS Linux Kernel 的方法&lt;/h2&gt;
&lt;p&gt;升级命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
yum clean all
yum update
&lt;/pre&gt;
&lt;p&gt;查看 Kernel 版本命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat /etc/redhat-release
&lt;/pre&gt;
&lt;p&gt;升级前:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
CentOS Linux release 7.4.1708 (Core)
&lt;/pre&gt;
&lt;p&gt;升级后:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
CentOS Linux release 7.5.1804 (Core)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;升级 CentOS Linux Kernel 后要做的事&lt;/h2&gt;
&lt;p&gt;升级完成后，我的开机菜单变成了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
CentOS Linux (3.10.0-862.6.3.e17.x86_64) 7 (Core)
CentOS Linux (3.10.0-693.21.1.e17.x86_64) 7 (Core)
CentOS Linux (3.10.0-693.e17.x86_64) 7 (Core)
CentOS Linux (0-rescue-4a8a974112aw410ea531fd24c60220bf) 7 (Core)
&lt;/pre&gt;
&lt;p&gt;可以看到多出了一个选项外，依然包括旧版本 Kernel，少数几个也不妨碍什么，只是多占用一点硬盘空间。&lt;/p&gt;
&lt;p&gt;如果想清理，可以先查看待删除的内核，命令如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
rpm -qa | grep kernel
&lt;/pre&gt;
&lt;p&gt;再删除旧版本的内核包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
yum autoremove kernel-.el7.x86_64
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;闲话几句&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Linux &lt;a class="reference external" href="https://www.kernel.org/"&gt;Kernel&lt;/a&gt; 即操作系统核心软件。有数据表示50%+的互联网服务器是 Linux，加上移动时代的 Android 占据半壁江山。可以这么说，&lt;em&gt;一半以上大部分计算设备内都运行了一份 Linux 核心&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;论贡献，豪不夸张，这个由神级人物 Linus Torvalds 领导开发了27年的软件，是现代文明的重度的坚实依赖，它是实用者的胜利，也是 Linus Torvalds 价值观的成功检验；&lt;/li&gt;
&lt;li&gt;Linux 的历史和文化值得慢慢了解、品位和思考，但现在大多情况下，云端机器 Linux 内核都是 3.x 版本，是不用升级的，除非你知道为什么要升级，或者你认为升级内核不重启机器的能力确实很酷；&lt;/li&gt;
&lt;li&gt;在国内，除非天时地利人和，研究 Linux Kernel 并没什么太多商业价值，只是领域情怀或“我乐意”；&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.elrepo.org"&gt;https://www.elrepo.org&lt;/a&gt; 和 &lt;a class="reference external" href="https://kernelnewbies.org"&gt;https://kernelnewbies.org&lt;/a&gt; 可能对你有用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="CentOS"></category><category term="Linux Kernel"></category></entry><entry><title>在 Linux 上安装 VSCode 遇到的问题和解决思路</title><link href="https://kaffa.im/install-vscode-on-linux-error.html" rel="alternate"></link><published>2018-07-05T12:30:00+08:00</published><updated>2018-07-05T12:30:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-07-05:/install-vscode-on-linux-error.html</id><summary type="html">&lt;p class="first last"&gt;本文描述在 Linux 上安装 VSCode 遇到的问题和解决思路&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;为什么在 Linux 上安装 VSCode？&lt;/h2&gt;
&lt;p&gt;近期计划使用搭建 telegram bot，了解原理后，发现是基本的 http 开发。&lt;/p&gt;
&lt;p&gt;计划使用轻量级 Web 框架，就项目需求来说，选择 Python 微框架 或 Go 语言比较适宜，加上前不久了解到类似 &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 的框架 &lt;a class="reference external" href="https://vibora.io/"&gt;Vibora&lt;/a&gt;，其官方介绍中的性能基准测试结果惊人难以置信，于是选择尝试，饶有兴致运行官方 hello world&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;vibora&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Vibora&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vibora&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="nd"&gt;@app.route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;home&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;b&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Hello world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;却发现无法在 Windows 下运行，提示:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Traceback (most recent call last):
File &amp;quot;test_vibora.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    from vibora import Vibora, JsonResponse
File &amp;quot;C:\Python36\lib\site-packages\vibora\__init__.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    from .server import *
File &amp;quot;C:\Python36\lib\site-packages\vibora\server.py&amp;quot;, line 5, in &amp;lt;module&amp;gt;
    from signal import pause
ImportError: cannot import name 'pause'
&lt;/pre&gt;
&lt;p&gt;查看源代码，是因为 vibora 使用了 Linux signal 的原因，看来，虽然其文档中称支持 Windows 是其目标，但目前还不支持。&lt;/p&gt;
&lt;p&gt;由于服务器是 CentOS，于是选择在本地虚机装上桌面，直接采用 VSCode 或 PyCharm 进行开发调试。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;按照微软官方 &lt;cite&gt;VSCode 的 Linux 安装帮助&lt;/cite&gt;，本应该四个命令就可以搞定:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo sh -c 'echo -e &amp;quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&amp;quot; &amp;gt; /etc/yum.repos.d/vscode.repo'
yum check-update
sudo yum install code
&lt;/pre&gt;
&lt;p&gt;可是在执行最后一个命令时，出现了一系列的 404 错误，安装终止了，提示:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Error downloading packages:  libXScrnSaver-1.2.2-6.1.el7.x86_64
&lt;/pre&gt;
&lt;p&gt;看样子是因为VSCode所依赖的某个软件包，提示资源不存在，yum 命令没能下载成功。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;解决思路&lt;/h2&gt;
&lt;p&gt;笼统的说，之前写过一篇 &lt;a class="reference external" href="http://kaffa.im/the-effective-way-to-find-answers-to-programming-questions.html"&gt;解决编程领域难题的有效方法&lt;/a&gt;，提到 StackOverflow，但此问题并不能很直接搜索到解决思路，所以只能自己思考。&lt;/p&gt;
&lt;p&gt;按照 yum 的提示去对应 &lt;a class="reference external" href="http://mirror.centos.org/centos-7/"&gt;CentOS 7&lt;/a&gt; 目录才发现，原来是 &lt;a class="reference external" href="http://mirror.centos.org/centos-7/7.5.1804/"&gt;CentOS 7.5.1804&lt;/a&gt; 到 Main Line 版本了。&lt;/p&gt;
&lt;p&gt;于是这个包依赖问题可以从 &lt;a class="reference external" href="http://mirror.centos.org/centos-7/7.4.1708/readme"&gt;CentOS 7.4.1708 readme&lt;/a&gt; 得到解答，即 &lt;a class="reference external" href="https://kaffa.im/update-centos-linux-kernel/"&gt;升级 CentOS 7.4 到 CentOS 7.5&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;升级完成后，再次运行 &lt;tt class="docutils literal"&gt;sudo yum install code&lt;/tt&gt;，即成功。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="CentOS"></category><category term="VSCode"></category><category term="Linux"></category></entry><entry><title>数据与信息的描述与差别</title><link href="https://kaffa.im/data-vs-information.html" rel="alternate"></link><published>2018-06-28T10:55:00+08:00</published><updated>2018-06-28T10:55:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-06-28:/data-vs-information.html</id><summary type="html">&lt;p class="first last"&gt;本文描述数据和信息两个概念的差别&lt;/p&gt;
</summary><content type="html">&lt;p&gt;编写文档时，大家常把 &lt;strong&gt;数据&lt;/strong&gt; 和 &lt;strong&gt;信息&lt;/strong&gt; 两个词混用，如管理信息系统（Management Information System）、数据导入（Data Import）等，可见，日常大家并不太在意两者的区别。&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;描述&lt;/h2&gt;
&lt;p&gt;数据是原始的、未经组织的、待处理的客观事实，数据在组织前，可能是简单的、看起来随机的和无用的，当把数据处理、组织或在上下文中呈现而变得有用后，数据就成为信息。&lt;/p&gt;
&lt;p&gt;举个例子，每隔 1 小时记录某地点的气温，可以得到 24 个数据，而连续记录很多天后计算这个地点的平均气温，或将这些数据画在一张分布图上用来做什么时，就可称之为信息。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;起源&lt;/h2&gt;
&lt;p&gt;“数据”这个词来源于拉丁语 datum 的单数形式, 最初表示“已知数”，最早被用于 17 世纪，后来 &amp;quot;数据&amp;quot; 变迁为 datum 的复数形式。&lt;/p&gt;
&lt;p&gt;“信息” 是一个更老的词汇，最早可以追溯到 14 世纪的法国和英国中部，通常指 “通知行为” 本身, 经常用在教育和知识领域。&lt;/p&gt;
&lt;p&gt;在语言的发展中，可能有一些约定的说法，比如“大数据时代”、“信息大爆炸”，从这些词也可以大概分出，由原始的数据可以组织出更可观的信息。&lt;/p&gt;
&lt;p&gt;数据和信息是讨论很多问题时的基础，因此有此篇。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="Data"></category><category term="Information"></category></entry><entry><title>Windows 下使用 VSCode 编辑 *.rst 文件的错误提示</title><link href="https://kaffa.im/vscode-restructuredtext.html" rel="alternate"></link><published>2018-06-20T02:52:00+08:00</published><updated>2018-06-20T02:52:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-06-20:/vscode-restructuredtext.html</id><summary type="html">&lt;p class="first last"&gt;本文提供消除 Windows 下使用 VSCode 编辑 *.rst 文件的错误提示的方法&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="id1"&gt;
&lt;h2&gt;问题出现的场景&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;使用 VSCode 编辑 *.rst 文件时，会提示安装 doc8 ，于是使用 pip 安装 doc8，执行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pip install doc8
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;重新打开文件，全文会出现两条警告 D002 和 D004，如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
'D002 Trailing whitespace'
'D004 Found literal carriage return'
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;D002 信息按字面意思是行尾有空格，稍作思考，感觉可能和 Windows 的换行符 CRLF 有关，
于是点击 VSCode 状态栏，修改 &lt;tt class="docutils literal"&gt;CRLF&lt;/tt&gt; 为 &lt;tt class="docutils literal"&gt;LF&lt;/tt&gt;，之后错误提示消失。请参考：&lt;a class="reference external" href="https://github.com/vscode-restructuredtext/vscode-restructuredtext/issues/84"&gt;issues-84&lt;/a&gt;&lt;/p&gt;
&lt;ol class="arabic" start="3"&gt;
&lt;li&gt;&lt;p class="first"&gt;又产生新的警告 D001，如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
'D001 Line Too Long'
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;a class="reference external" href="https://github.com/vscode-restructuredtext/vscode-restructuredtext/issues/83"&gt;issues-83&lt;/a&gt; 中给的解决方法是，在 VSCode 的用户配置中提供一个更大的行宽度值。
于是 &lt;tt class="docutils literal"&gt;Ctrl + P&lt;/tt&gt;，选择 &lt;tt class="docutils literal"&gt;Preferences: Open Settings&lt;/tt&gt;，在 &lt;tt class="docutils literal"&gt;User Settings&lt;/tt&gt; 标签页，
也就是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\Users\username\AppData\Roaming\Code\User\settings.json&lt;/span&gt;&lt;/tt&gt; 文件加入如下配置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;restructuredtext.linter.extraArgs&amp;quot;: [
    &amp;quot;--max-line-length 80&amp;quot;
]
&lt;/pre&gt;
&lt;p&gt;我的理解是，这个最大行宽在 *.rst 文件中不建议设置太大，大约每行最多 80 个字符就差不多了，
这个和可维护性代码的最佳实践是一致的。&lt;/p&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" /&gt;
&lt;/div&gt;
</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="VSCode"></category><category term="reStructuredText"></category><category term="rst"></category></entry><entry><title>解决编程领域难题的有效方法</title><link href="https://kaffa.im/the-effective-way-to-find-answers-to-programming-problems.html" rel="alternate"></link><published>2018-06-18T02:22:00+08:00</published><updated>2018-06-18T02:22:00+08:00</updated><author><name>Kaffa</name></author><id>tag:kaffa.im,2018-06-18:/the-effective-way-to-find-answers-to-programming-problems.html</id><summary type="html">&lt;p&gt;解决编程领域难题的有效方法是推演和搜索&lt;/p&gt;</summary><content type="html">&lt;h2&gt;为什么会有编程领域的难题？&lt;/h2&gt;
&lt;p&gt;现实世界很复杂，编程是世界的抽象和理想模型，理想和现实的差距存在于细节上，编程经常会遇到这些细节带来的鸿沟。&lt;/p&gt;
&lt;h2&gt;解决编程领域难题的有效方法是什么？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;独立思考&lt;/p&gt;
&lt;p&gt;一般来讲，大多数问题都是读的太少而想的太多带来的。在允许的情况下，推荐独立阅读思考的方式来解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向外部求助&lt;/p&gt;
&lt;p&gt;为了解决一个具体问题，第一步是将问题定义清楚，第二步将问题复杂度降维，例如采用正交的方式分解。
在决定向外部求助时，首选当然是浏览官方网站文档，毫无疑问，这是最新一手参考资料。
如果再推荐一个有效而快速的解决，无疑是 &lt;a href="https://www.stackoverflow.com"&gt;Stack OverFlow&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;编程领域问题两种分类维度：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;按平台和设备&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桌面系统&lt;ul&gt;
&lt;li&gt;Windows：最佳效率桌面系统&lt;/li&gt;
&lt;li&gt;macOS：与 Windows 相比，有所长，有所短&lt;/li&gt;
&lt;li&gt;GUN/Linux：建议玩 CentOS 或 Debian&lt;ul&gt;
&lt;li&gt;Debian：以服务稳定闻名&lt;/li&gt;
&lt;li&gt;Ubuntu：最流行易用&lt;/li&gt;
&lt;li&gt;openSUSE：界面好看&lt;/li&gt;
&lt;li&gt;Fedora：RHEL创新实验田&lt;/li&gt;
&lt;li&gt;CentOS：RHEL换商标版，一个靠谱的服务器版选择&lt;/li&gt;
&lt;li&gt;Arch Linux：功能全定制&lt;/li&gt;
&lt;li&gt;Gentoo：功能定制靠编译&lt;/li&gt;
&lt;li&gt;Raspbian：极客爱玩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unix&lt;ul&gt;
&lt;li&gt;FreeBSD：玩BSD桌面首选&lt;/li&gt;
&lt;li&gt;OpenBSD：可能是世界上最安全的系统&lt;/li&gt;
&lt;li&gt;NetBSD：多CPU架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Chrome OS：基于浏览器的计算环境&lt;/li&gt;
&lt;li&gt;Xfce：轻量级多媒体桌面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移动设备&lt;ul&gt;
&lt;li&gt;Android：移动设备半边天&lt;/li&gt;
&lt;li&gt;iOS：先进的移动OS&lt;/li&gt;
&lt;li&gt;Windows Phone：输在移动OS的设计&lt;/li&gt;
&lt;li&gt;Firefox OS：低端机好用&lt;/li&gt;
&lt;li&gt;Sailfish/Meego：寄予厚望却错过时代&lt;/li&gt;
&lt;li&gt;Sybian/WinCE/PalmOS/NucleusOS：历史&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;穿戴设备&lt;ul&gt;
&lt;li&gt;watchOS：目前最成功的手表OS&lt;/li&gt;
&lt;li&gt;Android Wear：没有机会用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平板设备&lt;ul&gt;
&lt;li&gt;iPad：打破PC思维，基于场景的资讯、娱乐和媒体平台&lt;/li&gt;
&lt;li&gt;Android Tablet：生产力平板&lt;/li&gt;
&lt;li&gt;Kindle：读书人最好&lt;/li&gt;
&lt;li&gt;Windows RT：不能运行传统程序的 Windows 大家不买单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浏览器&lt;ul&gt;
&lt;li&gt;Trident：作古&lt;/li&gt;
&lt;li&gt;Webkit：将作古&lt;/li&gt;
&lt;li&gt;Gecko：作古&lt;/li&gt;
&lt;li&gt;Presto：有前景&lt;/li&gt;
&lt;li&gt;Servo：有前景&lt;/li&gt;
&lt;li&gt;Blink：有前景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Web&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按语言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按类型模型&lt;ul&gt;
&lt;li&gt;强类型&lt;/li&gt;
&lt;li&gt;弱类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按范式&lt;ul&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;函数式&lt;/li&gt;
&lt;li&gt;过程式&lt;/li&gt;
&lt;li&gt;多范式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按交互&lt;ul&gt;
&lt;li&gt;编译型&lt;/li&gt;
&lt;li&gt;解释型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按热度&lt;ul&gt;
&lt;li&gt;不会不好意思打招呼系列&lt;ul&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大公司都用系列&lt;ul&gt;
&lt;li&gt;C/C++&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聪明系列&lt;ul&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;Delphi&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快系列&lt;ul&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有Qian景系列&lt;ul&gt;
&lt;li&gt;Swift&lt;/li&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;li&gt;Kotlin&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;科研系列&lt;ul&gt;
&lt;li&gt;F#&lt;/li&gt;
&lt;li&gt;R&lt;/li&gt;
&lt;li&gt;Matlab&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;极客系列&lt;ul&gt;
&lt;li&gt;Clojure&lt;/li&gt;
&lt;li&gt;Perl&lt;/li&gt;
&lt;li&gt;Rust&lt;/li&gt;
&lt;li&gt;Assembly&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;编程领域问题的根本难度&lt;/h2&gt;
&lt;p&gt;编程领域问题不仅仅只有分类，根据金字塔原理，分类是一种局部但重要的思维模式，解决问题最终依赖的是网状的知识图谱。
从长远来看问题的解决最终依赖于自我的学习力，而决定编程领域问题的根本难度可能在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;语言障碍
    因为语言学习本身不是短时间能解决的问题，所以如果当待解决的问题所依赖的知识与提问的人之间存在语言障碍，那么解决此问题将会面临一个较高难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自我认知
    有一本书叫做《提问的艺术》，可以参考。从测试的角度上，一个好提问，需给回答的人创造一个条件，方便回答者重现或进入问题的场景，一个自我认知好的人容易提好问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;解决编程领域难题的有效方法是推演和搜索&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;推演
    即依赖自我认知&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索
    除了依赖自我，更多的是依赖外部&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;感谢观阅，如果您觉得有用，可以扫我的赞赏码，鼓励一杯咖啡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的赞赏码" src="https://kaffa.im/img/reward.png" title="我的赞赏码" /&gt;&lt;/p&gt;</content><category term="随笔"></category><category term="Essays"></category><category term="技术"></category><category term="Technology"></category><category term="技术知识分类"></category><category term="Technology Category"></category><category term="问题解决"></category><category term="Problem Solving"></category></entry></feed>